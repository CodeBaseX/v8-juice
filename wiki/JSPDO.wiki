#summary A PDO-like db access abstraction binding for v8.
#labels Phase-UserDocs,Topic-JS-API

<wiki:toc max_depth='4'></wiki:toc>

*Achtung:* JSPDO is very new (born on 2011-06-11), thus it is beta. i may still randomly change how it behaves, it is quite lacking in documentation, and it is possibly missing some significant features.

=About JSPDO=

JSPDO is a database access abstraction API, modelled heavily off of the [http://php.net/manual/en/book.pdo.php PHP PDO] API. The underlying database abstraction library is called [http://fossil.wanderinghorse.net/repos/cpdo/ cpdo] and is implemented in C. JSPDO provides a v8 wrapper around cpdo.

Requirements:

  * libv8, of course
  * [V8Convert] (it's a header-only library, so there is no major installation hassles).
  * Some patience - the build tree is currently only designed to build directly from [http://code.google.com/p/v8-juice/source/browse/#svn/convert/addons/jspdo the original source tree] packaged together with [V8Convert]. i hope to modularize it someday to make it easy to drop in to arbitrary `v8::convert`-using clients.

Supported Drivers:
  * sqlite3
  * MySQLv5

See the [http://fossil.wanderinghorse.net/repos/cpdo/ cpdo home page] for more info than you could possibly want to know about it. The source tree includes a complete copy of the cpdo library - it does not need to be installed separately.

==Notable TODOs==

The more significant ones:

  * Document it. i'll do that once i'm happy with it.
  * Add several convenience functions for fetching and binding column data as an object (key/value pairs).
  * The underlying C lib is missing a couple of features which might be needed for advanced use, but it's functional enough for everything i've needed to do so far.

==Plugging JSPDO into your Application==

TODO: document how to do this.


=Important Details to Keep in Mind=

==#1: Lifetime Issues==

Database connections and the objects they create have very strict rules about when they must be cleaned up. The JSPDO class has a method called `close()` to release all resources owned by the database connection. The statement handle class (returned by `JSPDO.prepare()`) has a `finalize()` method which _must_ be called _before_ the parent `JSPDO` instance is `close()`ed, or Undefined Behaviour will ensue.

==#2: Error Reporting/Handling==

The vast majority of the functions in this API report errors via exceptions. Exceptions, for all their merits, make it easy to write code which does not properly finalize query/result set data. Get in the habit of using a `try/finally` block, as shown in the examples below, to ensure that statement handles are properly cleaned up. If a single statement handle is closed _after_ its database connection is closed, the v8 engine may very well crash as the statement handle steps on an invalidated database handle.

==#3: No Binary Data!==

This API will optimistically try to read BLOB fields as !JavaScript string data (because my databases of uses BLOB fields for storing string data, e.g. JSON data). If you tell it to read, e.g. binary image data, results are undefined. v8 makes its own assumptions about encoding and it assumes that we will feed it the proper type of data.

There are _no plans_ to add any direct binary data support to this API, as binary data is well outside of !JavaScript's comfort zone and i don't want to open up that can of worms.

==#4: Data Types ==

This code only explicitly accounts for numeric and string data, and there are some notable limitations regarding numbers. v8's `Integer` type only supports 32 bits. Thus this library tries to use `double` for integers of greater than 32 bits. It is conceivable that some floating-point numeric precision will be lost, depending on the underlying db driver and the exact field definitions.

When binding JS values to database fields for purposes of inserting data, this code tries its best to do the right thing, but it is possible that a specific db driver, or slightly different database table definition, will behave differently than another when it comes to numeric precision, maximum field length, and similar details. It is recommended that databases used with this code avoid constructs like 1-byte integer fields and similar things which may cause unexpected failures at runtime (depending on the driver). e.g. if the underlying native driver returns an error because we inserted the value 500 to a 1-byte integer field, then that will show up as a JS-side exception via this interface.


=JS API Overview=


Unless noted otherwise, the APIs report any "serious" errors via exceptions. Some types of errors (e.g. trying to convert a string to an integer) will not trigger explicit errors but may result in confusion on the user's part (e.g. converting a string to a number will always result in the value zero).

==JSPDO Class==

This class is synonymous with a database connection. Its main responsibilities are establishing a connection and doling out "statement" objects via its `prepare()` method.

|| *Method* || *Description* ||
|| `JSPDO(dsn[,userName,password])` || Connects to the database described in the given DSN string. See [http://whiki.wanderinghorse.net/wikis/cpdo/?page=DSN the cpdo wiki for details]. ||
|| `void exec(string)` || Executes simple SQL statements (those not returning values). ||
|| `Statement prepare(string)` || "Prepares" SQL code for execution. This is the only legal way to construct Statement objects. ||
|| `void close()` || Closes the db connection and frees any C-level resources allocated for the connection, _except_ for Statements, which _must_ be `finalize()`d _before_ their db is closed. ||
|| `int lastInsertId()` || Returns the "most recent" insertion ID for this connection, but this might not be the ID one may expect (triggers can cause IDs to be updated in ways opaque to the client application). ||
|| `void begin()` || Starts a transaction. Nested transactions are not supported. ||
|| `void commit()` || Commits the current opened transaction. ||
|| `void rollback()` || Rolls back the current transaction. ||

Instance properties (read-only!):

|| `string driverName` || The name of the underlying driver ("sqlite3" or "mysql5"). ||
|| `int errorCode` || The most recent error code (driver-specific). May be reset by the next call into the API. The code 0 is universally understood as success and a non-0 value is driver-dependent. ||
|| `string errorText` || The most recent error string (driver-specific). May be reset by the next call into the API. ||


Class-level properties (read-only!) (properties of the constructor function):

|| `Array driverList` || A list of the names of all available database drivers. ||
|| `Object columnTypes` || Mapping of symbolic names to integer values for use with the `columnType()` member of the statement class. ||


==Statements/Result Sets==

This class represents both prepared SQL statements and "result-set" data. This merging of functionality was inspired by PHP's PDO (which i happen to quite like). Most functions in this class only make sense for one mode of operation or the other (e.g. a read operation (e.g. `SELECT`) vs. a write (e.g. `INSERT`)).

These objects are _only_ to be created by calling `JSPDO.prepare()`, and not via a constructor call. The constructor is visible as `JSPDO.Statement`, but it is only in the public API so that clients may use it for `instanceof` checks. It should not be called by client code and the constructor's arguments are not publicly documented.

|| *Method* || *Description* ||
|| `void bind(index[,value])` || Binds a value (default=NULL) to the given _1-based_ parameter index or name (in the form `:paramName`). The _type_ of the given value determines how the value is bound (e.g. as an integer, double, or string). ||
|| `void bind(Array)` || Binds each value in the given array to the next subsequent bindable paramter. e.g. `bind([7,null,11])` binds parameters 1 to 3 with the given values. ||
|| `void bind(Object)` || Binds each key/value pair in the given object, treating the object's keys as bound parameter names. e.g. `bind({':p1',':p2':...})` ||
|| `bool step()` || "Steps" one row through a result set or executes a non-result query. Returns false if it is at the end of the set (or the query had no data to return, like an `INSERT`) or true if it successfully fetched a row. ||
|| `Array stepArray()` || Like `step()` but returns all of the columns from the fetched row as an array of values. It returns `null` at the end of the result set. ||
|| `Array stepObject()` || Like `step()` but returns all of the columns from the fetched row as an Object, using the column names as the object keys. It returns `null` at the end of the result set. ||
|| `mixed get(index)` || Returns a value from a fetched row, using the given _0-based_ column index. (The inconsistency is not mine - that's just how SQL APIs work!) This function _must not ever_ be called unless `step()` has returned true. Violating that leads to undefined behaviour. The JS type of the returned value will be deduced based on the database's data type. That basically means numbers "should" carry over as-is, SQL `NULL` translates to `null`, and everything else will be treated as a string. ||
|| `string columnName(index)` || The name of the 0-based result set column. ||
|| `int columnType(index)` || The cpdo-defined type ID for row data from the given 0-based column index. (Do not rely on stable values between releases!) ||
|| `void reset()` || Re-sets a statement so that it can be re-executed. Call this after each iteration when changing the values of bound parameters in a loop. ||
|| `int paramIndex(string)` || Returns the 1-based index of the given named bound parameter, or 0 if no such parameter is found. When using MySQL (which doesn't natively support named parameters), please read [http://whiki.wanderinghorse.net/wikis/cpdo/?page=cpdo_mysql5 the fine manual] regarding potential caveats. ||

Instance properties (read-only!):

|| `int errorCode` || The most recent error code (driver-specific). May be cleared by the next call into the API. The code 0 is universally understood as success and a non-0 value is driver-dependent. ||
|| `string errorText` || The most recent error string (driver-specific). May be cleared by the next call into the API. ||
|| `int paramCount` || The number of bound parameters in a prepared statement. ||
|| `int columnCount` || The number of columns in the current result set. ||

The majority of the functions report errors via exceptions. Because of that, statement-handling code _really really really should always_  be wrapped in a `try/finally` block, like this:

{{{
var st;
try {
    st = mydb.prepare(...);
    ... use st ...
}
finally { if(st) st.finalize(); }
}}}

Note that the `catch` part is optional - if it's not there then the behaviour is as if we had written `catch(e){throw e;}`. The important part is that the `finally` block is always executed, regardless of whether or not we catch the exception.

We could rewrite the above example a bit more briefly:


{{{
var st = mydb.prepare(...);
try {
    ... use st ...
}
finally { st.finalize(); }
}}}

There _may_ a subtle difference, however, depending on the code's context. `mydb.prepare()` might throw. In the second example, we would not catch that exception, but instead propagate it up the stack chain. Because of that, the `finally` block doesn't need to check if `st` was set. However, in some code constructs blindly propagating that exception might lead to resource leaks stemming from _other_ native objects which have specific cleanup requirements.


=How To ...=

See [JSPDO_HowTo].

=Caveats and Gotchas=

==Column Names might be Unpredictable! (Use "AS")==

Database drivers do not always guaranty what the name of a given column will be. e.g. when using sqlite the names are not guaranteed to match how they are named in the query unless the client uses an `AS` clause, e.g. `SELECT a as a, b as b from t...`.

==Opening Multiple Statement Concurrently (Don't do it!)==

Drivers are not required to allow more than one open result set for a given db connection (!MySQL, for example, does not allow it). Thus query code should be structured so that it does not need to open multiple queries at one time.

==Multi-Threading (Don't do it!)==

It is, in general, not legal (or not portable) for more than one thread to use the same connection (`JSPDO` instance), whether concurrently or not. If you use v8 in multiple threads, be sure that each thread has its own connection instance.