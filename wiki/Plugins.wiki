#summary Extending v8 with plugins
#labels Phase-UserDocs,Featured

=The Plugins API=

v8-juice provides an API for loading DLLs with the intent of adding functionality to a running JS engine.

List of current plugins (in alphabetical order):

  * [PluginNCurses ncurses]: ncurses bindings
  * [PluginReadline readline]: minimalistic GNU Readline/BSD Editline wrapper
  * [PluginSQLite3 sqlite3]: sqlite3 bindings
  * [PluginStringFuncs stringstuff]: supplemental string functions
  * [PluginWhio whio]: i/o device and stream classes

The plugins which are "standalone" (have no hard dependencies on external/third-party software other than v8) are in the core source tree under [http://code.google.com/p/v8-juice/source/browse/trunk/src/#src/lib/plugins src/lib/plugins]. Those which have external dependencies live in [http://code.google.com/p/v8-juice/source/browse/#svn/extra-plugins the extra-plugins repository].

Of your copy of juice is configured without plugins, the API for loading plugins will still be there (for consistency and binary compatibility), but they won't do anything useful.

==C++-side==

From C++ code, you need to do the following...

{{{
#include <v8/juice/plugin.h>
...
// when you initialize your JS global object, add this function:
  gl->Set(String::New("loadPlugin"), v8::juice::plugin::LoadPlugin );
}}}

That's all you need to do to enable the plugins support.

On Linux systems (and probably other Unices), your application must be linked with the `-export-dynamic` (also known as `-rdynamic`) flag, or DLLs may not be able to load properly (they won't be able to see the native LoadPlugin API provided by the application!).

Now, in the code which you want to link as a DLL you need to add a few small bits of code. First, we will assume you have a function with this signature:

{{{
Handle<Value> SetupMyAddon( Handle<Object> target );
}}}

That exact signature is not technically required, but it is a convenient convention and it required by the macro-based plugin initialization approach shown below.

That routine should add the plugin's functionality, treating the given target object as the logical global object (whether it is or is not the real global object is up to the caller). On success it should return a non-exception.

Now we set up a trigger which will call that init routine whenever the DLL is opened by adding the following macro somewhere in our implementation file (it doesn't matter where, as long as it's got file/namespace scope):

{{{
V8_JUICE_PLUGIN_STATIC_INIT(SetupMyAddon);
}}}

Now, whenever loadPlugin("!MyPlugin") opens the DLL, the initialization code will be run automatically and it can set up its JS state. Optionally, we can pass an Object as a second argument to loadPlugin(), and that object will be used as the local global object. Multiple plugins may live inside a single DLL, and the above macro needs to be called one time per plugin initialization function.

==JS-side==

{{{
loadPlugin("MyPlugin");
// or:
var p2 = {};
loadPlugin("MyOtherPlugin",p2); // will pass p2 as the target object
}}}

loadPlugin() will throw on error and the exception will explain the problem, which is normally one of:

  * No plugin could be found in the current plugins search path.
  * A plugin was found but opening it failed (e.g. missing DLL symbols are sometimes problematic).
  * The DLL initialization code threw an exception.

==The plugins search path==

From native code, you can use the PluginsPath() function to get access to a v8::juice::PathFinder object which is used to do the actual searches for plugins. The plugins path is accessible via JS code if it has been explicitly added using (see v8::juice::plugin::SetupPathFinderClass()). Once it is added to the JS engine, the plugins path is accessible via the shared JS object `PathFinder.shared.plugins` (in fact, it is the same native instance returned by the PluginPath() function).

For example:

{{{
print(PathFinder.shared.plugins.pathString);
print(PathFinder.shared.plugins.pathArray);
print(PathFinder.shared.plugins.find("MyPlugin"));
  // ^^^ searches for MyPlugin.(dll|so) but does not open it
}}}


The default plugins search path is:
{{{
.
PREFIX/lib/v8/juice/JUICE_VERSION/plugin
PREFIX/lib/v8/juice/plugin
(note to self: is that still correct?)
}}}

Where `PREFIX` is the installation prefix (see [BuildingTheCode]) and `JUICE_VERSION` is the version of the library (set during the configuration process).

==DLLs are _never_ unloaded==

Even if the DLL init code throws an exception, DLLs are _never_ unloaded. It cannot be safely done. Period. Don't argue with me on this. i'm right, for once, so just let me be right.

Here's a pasted-in email which goes into a bit more detail about my fanatical beliefs on this topic:

{{{
On Thu, Mar 5, 2009 at 6:15 PM, Slide xxxxxxxxx wrote:
> I was reading your article "Classloading in C++: Bringing classloading
> into the 21st century" and was wondering if your classloader scheme
> also supports unloading of shared library and unregistering the class
> from the loader.

Hi, Alex!

That's a good question: my basic philosphical view is that unloading
is NEVER safe in the generic sense. Merely opening a DLL can trigger
abitrary code via static initialization, and that code can allocate
resources which may not get cleaned up when the DLL is unloaded (they
may also load other DLLs and then not close them (and they can't do so
safely because they can't know who's using the resources in that
DLL)). Doing even the most basic cleanup requires doing some symbol
lookup in the DLL to find the dtor function, cast it to the type you
want, and call it (which technically has undefined results if you cast
to a function pointer derived from a dlsym() `void *`, though it's
likely to work on most platforms). Even with such a system in place,
it's not generically impossible to rule out that the DLL has allocated
resources inside the main application which would no longer be valid
if the DLL is closed. When we consider that a DLL can itself open
other DLLs, and those DLLs may feed data or offer services to the main
application, the problem gets worse.

So, the short answer is, i've never added unload support. The first
variant i worked on did, and our app crashed continually when we
unloaded DLLs, so we quickly removed it. After thinking about it for
several years, i'm 100% convinced that no generic framework can make
any safety guarantees for an unload, and even the most rigorous
approaches to DLL unload can fail if any single init routine allocates
memory outside of the DLL's address (e.g. registered a classloading
callback function in the main app) and fails to clean it up. If any
client of that DLL managed to copy a pointer which was, unbeknownst to
that client, generated from a DLL, the client will crash when he then
references that pointer. It's just not safe.
}}}
(The article here's referring to is here: [http://wanderinghorse.net/computing/papers/])