#summary Overview of ClassWrap Policies
#labels Topic-CPlusPlus,Phase-UserDocs

*ACHTUNG: this page documents a new API and is far from complete.* The `ClassWrap` API was introduced on 20091025 - it is quite new and may still change significantly.

Please read the [ClassWrap] page for an overview of the binding API before reading this page.

<wiki:toc max_depth='3'/>

=!ClassWrap Policies =

ClassWrap (as documented on its own page) is policy-driven. The core binding
API provides only a small amount of the real code needed in binding
classes, and anything which can/should be genericized is defined by
various policy classes. This page provides an overview of the policies
and their uses.

Polices are template classes (or "class templates", if you prefer)
which are specialized or partially specialized to provide features
required for binding a specific type to JS. To implement a policy,
the client specializes the given policy template for his type
and implements the behaviour described in the policy class' API
documentation.

Policies fall into two general categories: option policies and
functional policies.  Option policies typically define only a single
constant value (a boolean or integer), and that constant is used in
enabling or disabling certain aspects of functional policies.
Functional policies each have a very specific role in the class
binding process, and typically provide one (sometimes two) functions
for performing their role.

Most policies can use defaults, but two policies in particular cannot
be defaulted (explained below).

All examples in this page, unless noted otherwise, assume that the code
is in the `v8::juice::cw` namespace (where ClassWrap lives).

== API Documentation ==

!ClassWrap has fairly extensive API documentation
[http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap.h in ClassWrap.h].


= Options Policicies =

Options policies hold constant values which are used as toggles or ranges
for various functional policies.


== `InternalFields` ==

The `InternalFields` policy specifies two values: the number of "internal fields"
(the v8 js-to-native mechanism) and the index of the internal field which holds
the native value.

The policy's interface looks like this:
{{{
template <typename T>
struct InternalFields {
    static const int Count = 1;
    static const int NativeIndex = 0;
};
}}}

The default implementation (Count=1, !NativeIndex=0) is suitable for all
but the wierdest class-binding cases. When specializing it, `NativeIndex`
must be smaller than `Count`, and neither may be negative. Violating this
constraint will trigger a compile-time assertion.

*Important:* when one bound class inherits another, it _must_ use the same
values as the parent type's policy. This can be accomplished by subclassing
the child specialization from the parent specialization. e.g.:

{{{
template <>
  struct InternalFields<Subclass> : InternalFields<BaseClass> {};
}}}

== `AllowCtorWithoutNew` ==

This policy is a toggle for the internal (to !ClassWrap) native object
construction process.

This policy looks like:

{{{
template <typename T>
struct AllowCtorWithoutNew
{
    static const bool Value = false;
};
}}}

And it specifies where the following JS code is equivalent:

{{{
var a = new MyType();
var b = MyType(); // ctor called without "new"
}}}

By default the second form will trigger an error from v8. If this toggle is
true then !ClassWrap internally treats the second form as the first form
by making the call to "new" itself.

The library does not support providing two different behaviours
depending on whether "new" is used or not.

== `ToNative_SearchPrototypesForNative` ==

This boolean policy is used by some of the `ToNative` policies (described
somewhere below) to specify whether or not they should traverse the
JS prototype chain when looking for the native object.

This policy looks like:

{{{
template <typename T>
struct ToNative_SearchPrototypesForNative
{
        static const bool Value = true;
};
}}}

What this means is:

If a JS-defined class inherits from a bound native class, the bindings
code can no longer find the native "this" object in that JS object
because that JS object's internal structure was not set up by the binding
layer.

If this toggle is off, the `ToNative` implementations which use this
toggle will only look in the first object of the prototype chain
(itself, in this case an instance of a class defined in script
code). If this toggle is on then some `ToNative` implementations will
start recursively walking up the prototype chain to look for the
native "this" object.

If a bound class will never need to be subclassed (either from JS or
another bound class) then this policy can be set to false. If
inheritance will ever play a role then it should be set to true. Not
doing so will eventually trigger JS-side exceptions when bound
functions are called and the associated native "this" object cannot be
found.


= Functional Policies =

Functional policies are those which add or change behaviours of the
binding processes. The list of functional policies, and very brief
descriptions of each:

  * `ClassName` defines the JS-side name of the classs.
  * `Factory` is responsible for creating and destroying natives.
  * `Extract` is responsible for extracting (`void*`) data from bound JS objects.
  * `ToNative` converts (JS Object)-to-(T). Basically a thin wrapper around the `Extract` policy.
  * `ToJS` converts (T)-to-(JS Object). This is not possible for the generic case, and there is no default implementation! (But it is not always needed.)
  * `WeakWrap` may be used to customize the binding/unbinding process, e.g. doing/undoing custom native-to-JS mappings.

All policies except `ToJS` and `Factory` have reasonable defaults
which should work for the many common cases. The `Factory` policy is
necessarily type-specific, but we have template classes which can
generate a Factory-compliant policy implementation from a list of
native constructors. The `ToJS` policy does not have a default
implementation because this cannot be done in the generic case (but
it is only needed if we need to pass (`T*`) _to_ JS space).

Each factory is described in more detail below.

== Class name ==

The !ClassName policy defines a bound class's JS-side name. It looks like:

{{{
template <>
struct ClassName<BoundNative>
{
    static char const * Value();
};
}}}

Alternately, we can call the following macro from the global scope:

{{{
JUICE_CLASSWRAP_CLASSNAME(BoundNative,"BoundNative");
}}}

which generates the above code.

There is no sensible default implementation, but some policy sets
provide this feature as part of their setup process.

== `Factory` ==

The Factory policy's responsibilities are creating and destroying
new instances of objects. It is one of the few policies for which
there is no default implementation. There are several base Factory
types which we can use to install construction/destruction support.

{{{
template <typename T>
struct Factory
{
  typedef typename convert::TypeInfo<T>::Type Type;
  typedef typename convert::TypeInfo<T>::NativeHandle NativeHandle;
  static NativeHandle Instantiate( Arguments const &  argv, std::ostream & exceptionText );
  static void Destruct( v8::Handle<v8::Object> jself, NativeHandle nself );
  static const size_t AllocatedMemoryCost = 0;
};
}}}


To simplify the class creation process, concrete implementations of
this interface are provided which use either the default constructor
or a list of overloaded constructors. See `Factory_NewDelete` and the
`Factory_CtorForwarder` family of classes for details.

To install one of the concrete policies, simply subclass the
`Factory<T>` specialization from the appropriate base
implementation. For example, the following creates a factory
implementation which creates native objects using `new T` and
destroys them using `delete t`:

{{{
template <>
    struct Factory<MyType> : Factory_NewDelete<MyType> {};
}}}

== `WeakWrap` ==

After a Factory policy creates a native object, the class binder
passes the object via this interface to allow the policy to do
any custom JS/Native binding it needs to perform on each object.
As an example, policies which implement more intricate JS/Native
conversions may need to map the object as being of a certain native
type (or types, when inheritance is used).

The policy interface is:

{{{
template <typename T>
struct WeakWrap
{
    typedef typename convert::TypeInfo<T>::NativeHandle NativeHandle;

    // Called right after Factory<T>::Instantiate().
    static void Wrap( v8::Persistent<v8::Object> const & jsSelf, NativeHandle nativeSelf );

    // Called right before Factory<T>::Destruct().
    static void Unwrap( v8::Handle<v8::Object> const & jsSelf, NativeHandle nativeSelf );
};
}}}

The default implementation does nothing, which is suitable for most cases.

== `Extract` ==

This policy serves two purposes:

  * Fishing (`void*`) handles out of JS objects.
  * Converting (`void*`) to null.

{{{
template <typename T>
struct Extract
{
    typedef typename convert::TypeInfo<T>::Type Type;
    typedef typename convert::TypeInfo<T>::NativeHandle NativeHandle;
    static void * ExtractVoid( v8::Handle<v8::Object> const & jo, bool searchPrototypes );
    static NativeHandle VoidToNative( void * x );
};
}}}

The `ExtractVoid()` member is responsible for fishing out the (`void*`)s which v8
holds for us. This is the easy part, philosophically speaking, and this functionality
is provided by the class `Extract_Base<T>`. The base implementation is suitable for
most, if not all, cases.

The `VoidToNative()` routine is responsible for converting a (`void*`)
to a native object. How it does that is up to the policy. The default
implementation simply uses `static_cast<T*>(void*)`, which is (despite
appearances) remarkably safe for the majority of use cases (and also
incidentally avoids several pitfalls related to inheriting one bound
class to another).

Design note: in fact, `VoidToNative()` should arguably be part of the
`ToNative` interface. The the evolution of this API favoured it being
in this class, however, for reasons i don't quite recall.

== `ToNative` ==

This policy is responsible for converting JS objects native objects.

In practice, this is simply a very thin wrapper around the `Extract`
policy, but concrete implementations exists which do other stuff, like
assist in certain lookups which are problematic when a JS class inherits
a bound native class.


This policy looks like:

{{{
template <typename T>
struct ToNative_WithNativeSubclassCheck
{
    typedef typename convert::TypeInfo<T>::NativeHandle NativeHandle;
    static NativeHandle Value( v8::Handle<v8::Object> const jo );
};
}}}

The default implementation should be suitable for most cases, but
clients should also look at the available concrete implementation for
more information.


== `ToJS` ==

This policy is responsible for converting bound native objects to
bound JS objects.  This is not possible for the generic case, and
there is no default implementation! However, this operation is only
needed if we bind to functions which return a native object, e.g.
`Foo * somefunc()`. It is not needed if (`Foo*`) will be passed
as function arguments (that is handled by `ToNative`).

The policy's interface is:

{{{
template <typename T>
struct ToJS
{
public:
    typedef typename convert::TypeInfo<T>::Type Type;
    typedef typename convert::TypeInfo<T>::NativeHandle NativeHandle;
    static v8::Handle<v8::Object> Value( NativeHandle );
};
}}}

Currently only the
[http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap_TwoWay.h TwoWay policy set]
implements the internals needed to support this operation.


= Utility Functions and Types =

TODO: describe the more useful ones here.

= Concrete Policy Implementations =

The library comes with enough parts to easily build your own policy sets.
For the barest of features, the only two policies which are _required_ to be specialized
by client code `ClassName` and `Factory`. The library also comes with base classes
and "policy sets" (collections of cooperating policies) to make it easy to plug in
a bound class with very little client-written code.

The following sections briefly describe some of the options.

== Defaults ==

Most of the policies have fairly reasonable defaults, which makes it fairly
easy to get started with binding a class.

Not all policies have default implementations. Notably:

  * `ClassName` be implemented.
  * `Factory` as well, but there are several useful base classes which do all the work (specializations must simply subclass them).

== !JuiceBind ==

This policy set provides type-safe JS-to-Native conversions
(i.e., no casts are used), but requires a small amount of memory per bound
object to maintain the void-to-T mappings.

This policy set is very easy to install, as documented in the header file:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap_JuiceBind.h JuiceBind]

== !TwoWay ==

This policy set provides type-safe JS-to-Native _and_ Native-to-JS
conversions (and no casts are used), but requires more memory per
binding than the other policies. However, it is also the only one
which provides a `ToJS` policy.

This policy set is very easy to install, as documented in the header file:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap_TwoWay.h TwoWay]


= Initializing !ClassWrap =

We need to initialize our class bindings somewhere. Conventionally
that looks something like this:

{{{
v8::Handle<v8::Object> SetupBoundNativeClass( v8::Handle<v8::Object> dest )
{
    typedef ClassWrap<BoundNative> CW;
    CW & b( CW::Instance() );

   // ... binding code goes here (see later examples) ...

   b.Seal(); // ends the binding process
   b.AddClassTo( dest ); // installs BoundNative class in dest
   return b.CtorTemplate()->GetFunction();
}
}}}

=Binding functions=

We can bind both `BoundNative` member functions and free functions
to the JS class using the power of C++ templates.

From our `SetupBoundNativeClass()` routine:

{{{
typedef convert::MemFuncInvocationCallbackCreator<BoundNative>
        ICM; // typing-saver
b.Set( "toString",
        ICM::M0::Invocable<std::string,&BoundNative::toString> );
b.Set( "setInt",
        ICM::M1::Invocable<void,int,&BoundNative::setInt );
b.Set( "getInt",
        ICM::M0::Invocable<int,&BoundNative::getInt> );

}}}

The `ICM` class is a utility class which saves a few bytes of typing.
The `ICM::M0` to `ICM::M9`, and `ICM:F0` to `ICM::F9` are
convenience typedefs for assisting in binding member (thus the M)
functions taking the given number of arguments.

We can also bind non-member native functions as JS members using
a similar approach:

{{{
typedef convert::InvocationCallbackCreator ICC; // typing-saver
b.Set( "sleep",
       ICC::F1::Invocable<unsigned int,unsigned int,::sleep> );
}}}

This templates _create_ functions which implement the `v8::InvocableCallback`
interface. The generated functions use the [ConvertingTypes type conversion API]
to convert their arguments from their native counterparts and convert
the return value to a native value (or JS `undefined` for `void` return types).

=Binding member variables=

We can bind native member variables to JS space, such that all
get/set access is directed through the native variables. Alternately,
we can bind JS properties to native getter/setter functions, such that
all access to the property goes through those accessors.

This requires a slightly different approach than binding
functions:

{{{
typedef convert::PropertyBinder<BoundNative> PB;
v8::Handle<v8::ObjectTemplate> cwproto = b.Prototype();

// Bind BoundNative.myInt to BoundNative::getInt() and BoundNative::setInt():
PB::BindGetterSetter<int,
                     &BoundNative::getInt,
                     void,int,&BoundNative::setInt>
                     ( "myInt", cwproto );

// Bind BoundNative.intGetter read-only to BoundNative::getInt()
PB::BindGetter<int,&BoundNative::getInt>( "intGetter", cwproto );

// Bind BoundNative.publicProperty to BoundNative::publicProperty:
PB::BindMemVar<double,
              &BoundNative::publicProperty>
              ( "publicProperty", cwproto );

// Bind BoundNative.publicPropertyRO read-only to BoundNative::publicProperty:
PB::BindMemVarRO<double,
                 &BoundNative::publicProperty>
                 ( "publicPropertyRO", cwproto );
}}}

(TODO: add convenience funcs for those in the !ClassWrap interface.)

We can also bind JS properties to static variables, using `PB::BindStaticVar()`.

= Caveats and Gotchas =


== Inheritance doesn't come for free ==

Crossing the JS/C++ lines poses several problems for bound classes.

The more glaring ones are:

  * JS-side subclass complicate the lookup of the native `this` pointer which is stored internally in the JS object.
  * When one bound type inherits another, inherited bound native functions called from the subclass may not be able to find their own `this` pointer because the subtype is not exactly the same type as the parent.


The good news is that there are ways around these problems, and the default !ClassWrap
policies try to make these problems go away to the best of their ability.

TODO: document this when you're less tired.

==Achtung: Beware of Copies!==

Consider the following members:

{{{
typedef std::list<std::string> StringList;
StringList MyClass::getList() const;
void MyClass::setList( StringList const & );
}}}

These can be bound to a member, such that getting the member via JS
would return an Array of String object, and setting it would convert
the value to an Array of Strings. That's all fine and good, but
be very aware that that particular conversion _requires copying list_.
The two main implications are that (1) such access may not be cheap,
depending on the conversion necessary for the getter/setter,
and (2) the following _will not work in an intuive manner_:

{{{
var ar = ["hi", "world" ];
myobj.list = ar; // COPIES ar!
ar.push("!"); // does NOT modify myobj.list
// myobj.list.length == 2
// ar.length == 2
}}}

Thus it is not generically possible to update JS references
via this approach.

That said, the following is kosher _if_ a specialization
of the !ClassWrap `ToJS<>` policy is in place to convert
from natives to JS. (Such support requires extra tooling in the
policy classes, and the `ClassWrap_TwoWay.h` policy set
provides this.)

{{{
MyClass * MyClass::getBuddy();
void MyClass::setBuddy( MyClass * );
...
PB::BindGetterSetter<MyClass *,
                     &MyClass::getBuddy,
                     void,MyClass *,&MyClass::setBuddy>
                     ( "buddy", b.Prototype() );

// JS:
var o1 = new MyClass();
o1.buddy = new MyClass(); // calls MyClass::setBuddy(new object)
...
print( o1.buddy ) // will act on that same MyClass instance.
}}}

Getting/setting such a property via these bindings will work
as expected as long as the property refers to another
bound `MyClass` object.

_HOWEVER_, there is another caveat: in the above specific case, we "should"
give JS an explicit handle to the newly-created object or we risk it getting
garbage collected because the native member conversions to not store a
reference to the new object in JS space (only in native space). Thus it is
possible, in the above example, that calling `o1.buddy` in a "get" context
would return null or an empty object if GC is called between the assignment
and the call to `print()`.

The general workaround for this problem is to stuff a reference to the
new object somewhere:

{{{
o1._refs = [];
o1.buddy = (o1._refs[o1._refs.length] = new MyClass());
...
print( o1.buddy ); // this is now safe
}}}

That is somewhat lame, but it is a generic problem for many types of
JS-to-Native bindings. (When i first encountered it, it took me an hour
to figure out why my new objects kept disappearing.)


==Return values of native setter members==

Be aware that the return value of a native setter function is
_ignored_ for binding purposes because that's how the JS API works in
regards to assignment.  This example should clarify:

{{{
myobj.prop = 12; // MyClass::setProp(12)
print( myobj.prop += 3 ); // is essentially (but not exactly) equivalent to:
// print(
//      ( MyClass::setProp( MyClass::getProp() + 3 ),
//        MyClass::getProp() )
// );
// (Recall that (a,b,c...) evaluates to the last expression in the list)
}}}

In actuality `getProp()` is not called a second time in the `print()`
expression (though i'm honestly not entirely sure why not), but the
effect is essentially as if it is called (assuming the getter has no
side effects which would affect the second call).

Thus the assignment operation returns the JS-internal value of the
assignment, and _not_ the return value of `MyClass::setProp()`. This
is a property (feature or limitation?) of the v8 property accessor
binding API.

=Example of using !ClassWrap=

The complete test/demo code for !ClassWrap can be found here:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/client/sample/BoundNative/BoundNative.cpp BoundNative.cpp]