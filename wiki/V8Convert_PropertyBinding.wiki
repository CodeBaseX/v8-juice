#summary V8Convert's native property-binding API
#labels Phase-UserDocs,Topic-CPlusPlus

<wiki:toc/>

= Introduction =


The `cvv8` property binding API provides the following features:

[V8Convert] has a flexible approach to binding native non-function properties to JS. It uses templates to create `v8::AccessorGetter` and `v8::AccessorSetter` functions, which are the property-side counterparts of `v8::InvocationCallback`. It is superficially similar to [V8Convert_FunctionBinding the function-binding API], and accessors can be created a number of ways. For example, we can bind JS-side properties to:

  * Global/namespace-scope variables.
  * Member variables (static and non-static).
  * Member methods which get/set proxy access.

Property binding is done at the level of the `v8::ObjectTemplate` class, which is roughly equivalent to the class level in C++ and represents the JS-side `prototype` object for a JS class. The examples on this page often refer to a `proto` object, which is an instance of `v8::ObjectTemplate`:

{{{
v8::ObjectTemplate proto = ... wherever you get your Prototype object from ...;
}}}

The examples also assume the following, for brevity/readability:

{{{
#define JSTR v8::String::New
}}}

= Achtung: Binding Methods/Member Variables =

Binding member variables or functions _requires_ that `CastFromJS<MyType>()` can convert the JS-side 'this' object to C++. Making that work is normally the function of a class-binding mechanism like [V8Convert_ClassCreator ClassCreator], but there are a number of ways to set it up without using that specific binding mechanism. Strictly speaking, `CastFromJS<MyType>()` must return a `(MyType*)` and the bindings throw JS exceptions if that conversion returns `NULL`.

Whether or not `CastFromJS()` can work is often not determinable at compile-time. i.e. it is possible (quite likely) that the code will compile fine even if the class is not "fully bound" as a JS class, but the inability to perform the conversion will only be detected when it is performed.

See [V8Convert_ClassCreator] for one approach (there are many possible approaches) to binding C++ classes to JS in a manner compatible with this API.

= Binding Non-member Variables =

Here's how to create create accessors for non-member variables or _static_ class members:

{{{
struct MyType { static int anInt; };
int MyType::anInt = 42;

...

proto->SetAccessor(JSTR("anInt"),
   VarToGetter<int,&MyType::anInt>::Accessor,
   VarToSetter<int,&MyType::anInt>::Accessor
);
}}}

Often we want to disable setting of a variable. To do that, do one of the following:

  * Use `ThrowingSetter::Accessor` as the setter, which will cause a JS exception to be thrown if the client assigns the variable.
  * Do not pass a setter to `SetAccessor()`. That might have undesired side-effects, though. IIRC, that leads to JS-set values "overriding" the variable, such that future `get` access reads the JS-assigned variable. (Again, IIRC.)
  * `SetAccessor()` has other default parameters which can be set to make a variable read-only (in which case setting it is simply ignored.


The same can be used for global/namespace-scope variables (which are fairly rare in practice).

= Binding Native Member Variables =

{{{
struct MyType { int anInt; };

...

proto->SetAccessor(JSTR("anInt"),
    MemberToGetter<MyType,int,&MyType::anInt>::Accessor,
    MemberToSetter<MyType,int,&MyType::anInt>::Accessor
);
}}}

After that, all JS-side access to `anInt` will directly proxy the native `MyType::anInt`. Assigning, e.g., an `Object` to it would perform a numeric conversion, leading to a value of `0`.

(TODO?: consider writing a type-strict variation which throws if the type is not strictly convertible.)

= Binding Native Methods as Property Accessors =

This isn't any different from binding non-function properties:

{{{
struct MyType {
    int getInt() const;
    void setInt(int);
};

...

proto->SetAccessor(JSTR("anInt"),
    ConstMethodToGetter<MyType,int (),&MyType::getInt>::Accessor,
    MethodToSetter<MyType,void (int),&MyType::setInt>::Accessor
);
}}}

After that, all JS-side access to `anInt` will go through `getInt()` and `setInt()`.

= Mixing Various Approaches =

Since the property binding API simply creates `v8::AccessorGetter()` and `v8::AccessorSetter()` functions, we can mix the various approaches. Here is a rather contrived example:

{{{
struct MyType {
    int anInt;
    void setInt(int);
};

...

proto->SetAccessor(JSTR("anInt"),
    MemberToGetter<MyType,int,&MyType::anInt>::Accessor,
    MethodToSetter<MyType,void (int),&MyType::setInt>::Accessor
);
}}}


= Tips and Ticks =

== Throwing Exceptions on Set Operations ==

To throw a JS exception if script code assigns a value to a property we can use `ThrowingSetter`:

{{{
proto->SetAccessor(JSTR("..."),
    ... some getter ...,
    ThowingSetter::Accessor
);
}}}