#summary V8Convert ClassCreator class-binding mechanism
#labels Topic-Project,Featured

[V8Convert]'s `ClassCreator` API is an easy-to-use template-based mechanism for binding native classes to JS. It was originally derived from [ClassWrap], making it the 3rd generation of class-binding mechanism since this project was started, and it is very similar to that binding mechanism. !ClassCreator's source code can be found [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/ClassCreator.hpp here].

Let's just jump straight to an example...

=Demo: Binding A Class in just Moments=

{{{
//-----------------------------------
// My favourite debugging mechanism...
#define CERR std::cerr << __FILE__ << ":" << \
        std::dec << __LINE__ << ":" <<__FUNCTION__ << "(): "

//-----------------------------------
// Required header(s):
#include "v8/convert/ClassCreator.hpp"

// Convenience typedef:
namespace cv = v8::convert;

//-----------------------------------
// The type we want to bind to v8.
struct MyType
{
    MyType() {
        CERR << "MyType::MyType() @ "<<this<<'\n';
    }
    MyType( int i, double d ) {
        CERR << "MyType::MyType("<<i<<", "<<d<<") @ "<<this<<'\n';
    }
    MyType( char const * str ) {
        CERR << "MyType::MyType("<<str<<") @ "<<this<<'\n';
    }
    MyType( v8::Arguments const & argv ) {
        CERR << "MyType::MyType("<<argv.Length()<<" arg(s)) @ "<<this<<'\n';
    }
    ~MyType() {
        CERR << "MyType::~MyType() @ "<<this<<'\n';
    }
    
    // Ctors we want to bind to v8 (there are several other ways to do this):
    typedef cv::Signature<MyType (
        cv::CtorForwarder<MyType *()>,
        cv::CtorForwarder<MyType *(char const *)>,
        cv::CtorForwarder<MyType *( int, double )>,
        cv::CtorForwarder<MyType *( v8::Arguments const &)>
    )> Ctors;

    // Function we want visible to JS:
    int func( double ) { return 42; }
};

//-----------------------------------
// Policies used by cv::ClassCreator (it also has others)
namespace v8 { namespace convert {

    template <>
    class ClassCreator_Factory<MyType>
     : public ClassCreator_Factory_CtorForwarder< MyType, MyType::Ctors >
    {};
    template <>
    struct JSToNative< MyType > : JSToNative_ClassCreator< MyType >
    {};
}}

//-----------------------------------
// Ultra-brief ClassCreator demo. See ConvertDemo.?pp for MUCH more.
void bind_MyType( v8::Handle<v8::Object> dest )
{
    typedef cv::ClassCreator<MyType> CC;
    CC & cc(CC::Instance());
    cc
        ("destroy", CC::DestroyObjectCallback)
        ("func", cv::ToInCa<MyType, int (double), &MyType::func>::Call)
        .AddClassTo( "MyType", dest );

    // Real-life issue: if this function _might_ be called multiple
    // times in one app, we have to do a small bit more work to avoid
    // duplicate initialization. But that normally is not the case.
}
}}}

While there are lots of possibilities to customize the class-binding process, what is shown above is all that's needed for the basic cases. We generally do not have to modify the to-be-bound classes, but we often (due to differences in how C++ and JS see the world) have to write additional bits of shim/glue code to make specific bindings possible or more flexible.

If we simply construct/destruct a few of them from JS code:

{{{
(new MyType()).destroy();
(new MyType("hi")).destroy();
(new MyType(1,2.3)).destroy();
(new MyType(1,2,3,4,5)).destroy();
}}}

We will see something like:

{{{
demo.cpp:184:MyType(): MyType::MyType() @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:192:MyType(): MyType::MyType(hi) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:188:MyType(): MyType::MyType(1, 2.3) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:196:MyType(): MyType::MyType(5 arg(s)) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
}}}

Notice that the system's memory allocator re-allocated each new instance at the same address as the previously destroyed one. That is a mere fluke of the memory manager, and not a well-defined behaviour.

Real-world examples: the [http://code.google.com/p/v8-juice/source/browse/#svn/convert/addons addons directory] of the source tree contains several complete, non-trivial examples of custom bindings, e.g. [JSPDO], [V8Convert_Socket], and [V8Convert_ByteArray ByteArray].