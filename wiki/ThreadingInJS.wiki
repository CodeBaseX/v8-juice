#summary Basic multi-threading in JavaScript
#labels Phase-UserDocs,Topic-JS-API

<wiki:toc max_depth=4/>

= Basic multi-threading in !JavaScript =

Version 20090912 added the `setTimeout()` family of functions (see [BindableFunctions]). which can be used to implement the most basic multi-threaded features.


==setTimeout() and friends==

They are used like this:

{{{
function timeout()
{
   print("Timeout reached!");
}

setTimeout(timeout,1500);
sleep(3);
}}}

That will schedule the function `timeout()` to be called one time in 1500 milliseconds (1.5 seconds). The call to `sleep()` there is only to give the timeout function time to fire. Using sleep this way is _not_ a reliable way of ensuring that a certain timeout has been run, and is only used here for demonstration purposes.

To call a function at intervals, use `setInterval()` instead of `setTimeout()`, or have your timeout handler call `setTimeout()` when it is finished processing.

The `setTimeout()` and `setInterval()` functions returns a unique ID which can be passed to `clearTimeout()` or `clearInterval()` in order to cancel the calling of the callback function (assuming the clear routine is called before the timeout expires).

In this implementation (though apparently not per the client-side JS specification), `clearTimeout()` is equivalent to `clearInterval()`, and either can be used for both types of timeout IDs.

=Major Limitations=

The !JavaScript language specification does not define any sort of locking behaviour in the face of multiple threads. It is _impossible_, using JS-only constructs, to write 100% thread-safe code in !JavaScript. Keep that in mind when making use of `setTimeout()`.

==There is no Preemtion==

The v8 engine is internally single-threaded. At certain points during JS execution it checks to see if a thread is waiting to make use of of the engine (via constructing a `v8::Locker` object in native code). If you have a JS thread which is sitting in a tight loop and never triggers one of the v8-internal thread-preemtion checks (e.g. it never calls a function) then other threads might never get to run.

The `sleep()` family of functions will unlock the v8 engine while they are sleeping, and can be used in a thread to give v8 a chance to allow other threads to run. v8 _might_ do that anyway, but will only do so at certain points in its execution (namely function calls). Calling `sleep(0)` is one way to emulate a "yield" operation, as that unlocks the engine, allowing v8 to pass control to other threads, and then locks it again when control is given back to the original thread.

==Timing is Everything (and undefined)==

The addition of multiple threads in a process always adds some level of uncertainty in the timing of execution of the various threads. High-level languages which use unpredictable GC (and/or lack destructors) add even more uncertainty (destructors are a great way to simplify locking in languages which support them). Threads created via `setTimeout()` cannot be reliably used for high-resolution threading (that is, where threads are meant to interact at small, fixed intervals).

In the following code it is impossible to know with certainty which of the operations, running or cancelling the timeout, will happen first, due to the imprecision introduced via multi-threading and system-level timing issues:

{{{
var delay = 1;
var tid = setTimeout(function(){}, delay);
clearTimeout(tid);
}}}

Do not rely on JS code for this type of precision. If you need that level of thread control, do it in native code and (if needed) add a higher-level JS wrapper around that.

=Future possibilities=

"It would be nice" to have a JS-side Thread class, which could be called like:

{{{
var t = new Thread( callbackfunc );
t.start();
while( t.isRunning() )
{
   print("Waiting on thread...");
   mssleep(500);
}
}}}

however, i'm not yet up to that task, and currently can see little benefit over using `setTimeout()`, given all of the JS-implied limitations of the hypothetical Thread class. It's also not clear whether such a class should run in a detached or joinable mode (`setTimeout()` is detached).