#labels Phase-UserDocs,Topic-JS-API

#summary The JSPDO JS API.
#labels Phase-UserDocs,Topic-JS-API

<wiki:toc/>

See also: [JSPDO], [JSPDO_HowTo]

=JS API Overview=

This page provides an overview of the [JSPDO] JS API. See the [JSPDO_HowTo] page for examples of using it.

Unless noted otherwise, the API reports any errors via exceptions. Some types of errors (e.g. trying to convert a string to an integer) will not trigger explicit errors but may result in confusion on the user's part (e.g. converting a string to a number will always result in the value zero).

=JSPDO Class=

This class is synonymous with a database connection. Its main responsibilities are establishing a connection and doling out "statement" objects via its `prepare()` method.

|| *Method* || *Description* ||
|| `JSPDO(dsn[,userName,password])` || Connects to the database described in the given DSN string. See [http://whiki.wanderinghorse.net/wikis/cpdo/?page=DSN the cpdo wiki for details]. ||
|| `void exec(string|Object)` || Executes simple SQL string statements (those not returning values) or, if passed an Object, allows executing a callback for each returned row. Described in detail below. ||
|| `Statement prepare(string)` || "Prepares" SQL code for execution. This is the only legal way to construct Statement objects. ||
|| `void close()` || Closes the db connection and frees any C-level resources allocated for the connection, _except_ for Statements, which _must_ be `finalize()`d _before_ their db is closed. ||
|| `int lastInsertId()` || Returns the "most recent" insertion ID for this connection, but this might not be the ID one may expect (triggers can cause IDs to be updated in ways opaque to the client application). ||
|| `void begin()` || Starts a transaction. Nested transactions are not supported. ||
|| `void commit()` || Commits the current opened transaction. ||
|| `void rollback()` || Rolls back the current transaction. ||
|| `void fetchAll(object)` || Executes a query and returns all result records. Described in detail below. ||

Instance properties (read-only!):

|| `string driverName` || The name of the underlying driver ("sqlite3" or "mysql5"). ||
|| `int errorCode` || The most recent error code (driver-specific). May be reset by the next call into the API. The code 0 is universally understood as success and a non-0 value is driver-dependent. ||
|| `string errorText` || The most recent error string (driver-specific). May be reset by the next call into the API. ||
|| `string dsn` || The DSN string passed to the constructor. ||


Class-level properties (read-only!) (properties of the constructor function):

|| `Array driverList` || A list of the names of all available database drivers. ||
|| `Object columnTypes` || Mapping of symbolic names to integer values for use with the `columnType()` member of the statement class. ||

== exec(Object) ==

`exec(Object)` can be used to execute a query and call a callback function on each iteration:

{{{
db.exec({
  sql:"SELECT a,b,c FROM mytbl",
  mode:'array',
  callbackData:{rows:0},
  each:function(row,data,st){
      ++data.rows;
      print(row.join('\n'));
  }
});
}}}

The options supported by the function are:

|| `mixed sql` || The SQL (string) code to run. It may also be a Statement object, but this function _will not_ finalize it (regardless of success or failure). i.e. such an object is still owned by the caller. ||
|| `mixed bind` || An object or array of data to bind to the statement before execution. If it is a function then `f(statement,bindData)` is called (one time!), where `bindData` is the value of this object's `bindData` member. ||
|| `any bindData` || Optional data passed to `bind` if it is a function. ||
|| `function each(row,data,st)` || Is called for each row. The exact type of the 1st parameter depends on the `mode` property. The 2nd argument is the value of this object's `callbackData` member. The 3rd argument is the statement itself. If this is not a function then the statement is `step()`ed only one time (this is only useful for `INSERTS` and such). ||
|| `string mode` || If == "array", `each()` is passed an array object as the 1st parameter. "object" passes an object as the 1st parameter. Anything else causes the statement object itself to be passed. ||
|| `any callbackData` || Optional data passed as the 2nd argument to `each()`. ||

Note that the `each()` function is passed the statement handle as its final parameter. This is _only_ so that clients can fetch the column names if they need to. _Do not_ call `step()` or `bind()` on the handle from the `each()` callback - doing so will lead to unpredictable results and/or errors.

== fetchAll()==

`fetchAll()` is an `exec({...})` wrapper which returns _all_ matching rows of a select-style query in the following structure:

{{{
{ columns:[ column names... ], rows:[ records... ] }
}}}

It requires a single Object argument with the following properties: `sql`, `bind`, `bindData`, `mode`. All of those have the same semantics as they do for `exec({...})` exeept that `mode` must be one of the strings (`object`,`array`) and defaults to `array`.

Each record in the `columns` array corresponds to a result set column name. Their order is guaranteed to be the same as in the query.

Each record in the `rows` array will be either an Object or Array, depending on the `mode` option. If it is an object, the keys (property names) are _not_  guaranteed to be in the same order as in the original query (the ordering depends on internal details of v8's Object class implementation). In practice, they appear to be the same, but it's not _guaranteed_, which is why the `columns` property is always provided (because the ordering can be guaranteed).

Example:

{{{
var res = db.fetchAll({
    sql:"SELECT a AS a,b AS b,c AS c FROM mytbl",
    mode:"object", // default == "array"
});
print(JSON.stringify(res));
}}}


=JSPDO.Statement=

This class represents both prepared SQL statements and result-set data. This merging of functionality was inspired by PHP's PDO (which i happen to quite like). 

These objects are _only_ to be created by calling `JSPDO.prepare()`, and not via a constructor call. The constructor is visible as `JSPDO.Statement`, but it is only in the public API so that clients may use it for `instanceof` checks. It should not be called by client code and the constructor's arguments are not publicly documented.

|| *Method* || *Description* ||
|| `void bind(index[,value])` || Binds a value (default=NULL) to the given _1-based_ parameter index or name (in the form `:paramName`). The _type_ of the given value determines how the value is bound (e.g. as an integer, double, or string). ||
|| `void bind(Array)` || Binds each value in the given array to the next subsequent bindable paramter. e.g. `bind([7,null,11])` binds parameters 1 to 3 with the given values. ||
|| `void bind(Object)` || Binds each key/value pair in the given object, treating the object's keys as bound parameter names. e.g. `bind({':p1',':p2':...})` ||
|| `void bind(Statement)` || Binds all columns from the `Statement` object argument to the columns in the current statement. This can be used, e.g. to copy results from one table into another. TODO: accept array of param column numbers/names to copy, instead of copying all. ||
|| `bool step()` || "Steps" one row through a result set or executes a non-result query. Returns false if it is at the end of the set (or the query had no data to return, like an `INSERT`) or true if it successfully fetched a row. ||
|| `Array stepArray()` || Like `step()` but returns all of the columns from the fetched row as an array of values. It returns `null` at the end of the result set. ||
|| `Array stepObject()` || Like `step()` but returns all of the columns from the fetched row as an Object, using the column names as the object keys. It returns `null` at the end of the result set. ||
|| `mixed get(index)` || Returns a value from a fetched row, using the given _0-based_ column index. (The inconsistency is not mine - that's just how SQL APIs work!) This function _must not ever_ be called unless `step()` has returned true. Violating that leads to undefined behaviour. The JS type of the returned value will be deduced based on the database's data type. That basically means numbers "should" carry over as-is, SQL `NULL` translates to `null`, and everything else will be treated as a string. ||
|| `string columnName(index)` || The name of the 0-based result set column. ||
|| `int columnType(index)` || The cpdo-defined type ID for row data from the given 0-based column index. (Do not rely on stable values between releases!) ||
|| `void reset()` || Re-sets a statement so that it can be re-executed. Call this after each iteration when changing the values of bound parameters in a loop. ||
|| `int paramIndex(string)` || Returns the 1-based index of the given named bound parameter, or 0 if no such parameter is found. When using MySQL (which doesn't natively support named parameters), please read [http://whiki.wanderinghorse.net/wikis/cpdo/?page=cpdo_mysql5 the fine manual] regarding potential caveats. ||
|| `string paramName(index)` || Returns the bound parameter name at the given 1-based index, or null if the index is out of bounds (it does not throw on out-of-bounds like most other functions). ||

Instance properties (read-only!):

|| `int errorCode` || The most recent error code (driver-specific). May be cleared by the next call into the API. The code 0 is universally understood as success and a non-0 value is driver-dependent. ||
|| `string errorText` || The most recent error string (driver-specific). May be cleared by the next call into the API. ||
|| `int paramCount` || The number of bound parameters in a prepared statement. ||
|| `int columnCount` || The number of columns in the current result set. ||
|| `string sql` || The SQL string passed to the constructor. ||
|| `Array columnNames` || The names of the columns, for `SELECT`-like queries, else null. Equivalent to the function `columnName(int)`. ||
|| ~~Array columnTypes~~ || ~~Mapping of symbolic names to integer values for use with the `columnType()` member of the statement class.~~ (Removed 20110620 because of a semantic incompatibility with `columnType()`.) ||
|| `Array paramNames` || The names of all bound column parameters, if any, else null. _Note that_ the array indexes are 0-based whereas the `bind()` API uses 1-based indexes! ||


The majority of the functions report errors via exceptions. Because of that, statement-handling code _really really really should always_  be wrapped in a `try/finally` block, like this:

{{{
var st;
try {
    st = mydb.prepare(...);
    ... use st ...
}
finally { if(st) st.finalize(); }
}}}

Note that the `catch` part is optional - if it's not there then the behaviour is as if we had written `catch(e){throw e;}`. The important part is that the `finally` block is always executed, regardless of whether or not we catch the exception.

We could rewrite the above example a bit more briefly:


{{{
var st = mydb.prepare(...);
try {
    ... use st ...
}
finally { st.finalize(); }
}}}

There _may_ a subtle difference, however, depending on the code's context. `mydb.prepare()` might throw. In the second example, we would not catch that exception, but instead propagate it up the stack chain. Because of that, the `finally` block doesn't need to check if `st` was set. However, in some code constructs blindly propagating that exception might lead to resource leaks stemming from _other_ native objects which have specific cleanup requirements.

=How to...=

==Get the logical type of a column===

{{{
var t = myStatement.columnType(zero_based_index);
}}}

The return value will map to one of the values stored in `JSPDO.columnTypes`, which is a static set of string/integer pairs containing the logical type names and their C-level values. _Do not_ rely on the values being stable between releases - use only the symbolic names (the keys of the `JSPDO.columnTypes` object).

The full list of type symbol names is: `ERROR`, `NULL`, `INT8`, `INT16`, `INT32`, `INT64`, `FLOAT`, `DOUBLE`, `STRING`, `BLOB`, `CUSTOM`

Note that because v8's C++ API only supports integer values of 32 bits or less, JSPDO treats values greater than 32 bits as doubles. This _might_, depending on the db driver and schema-level settings, cause errors when trying to insert, e.g., a 33-bit value in a numeric db field declared as being 4 bytes (32 bits). JS itself does not really differentiate between integers and doubles - they're both classified as "numbers" in JS.

Note that drivers may report different types for the same column in different rows of the same result set. This is because:

  * This is how they report that a value is an SQL `NULL`.
  * sqlite3 allows any type to be stored in any column, regardless of the schema-declared types.

The MySQL driver, because it is "strongly typed", will always return the schema-declared type (or _something approximating it_!) _except_ in the case of SQL `NULL` values. It reports "is it NULL?" via a column type of `JSPDO.columnTypes.NULL`.

==Find out if a column is `NULL`==

The simplest way:

{{{
var v = myStatement.get(zero_based_index);
if( null === v ) { ... it is an SQL NULL ... }
}}}

It can also be determined by looking at the driver-reported type of the column:

{{{
var t = myStatement.columnType(zero_based_index);
if( JSPDO.columnTypes.NULL == t ) {
   ... the value is SQL NULL ...
}
}}}