#summary V8Convert ClassCreator class-binding mechanism
#labels Phase-UserDocs,Topic-JS-API

[V8Convert]'s `ClassCreator` API is an easy-to-use template-based mechanism for binding native classes to JS. It was originally derived from [ClassWrap], making it the 3rd generation of class-binding mechanism since this project was started, and it is very similar to that binding mechanism. !ClassCreator's source code can be found [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/ClassCreator.hpp here].

To allow customization of the binding process, `ClassCreator` uses so-called policy classes. These are templates which clients may specialize to customize various aspects of the bindings without having to touch the ClassCreator code. In effect they are "hooks" into various specific points of the class-binding mechanism. e.g. one policy determines how we actually associate the native and JS objects with one another ("quick-and-easy" vs. "slower but typesafe"). Most, but not all, policies have reasonable default implementations. A small number of them require the client to provide his own specialization (this is demonstrated below).

Let's just jump straight to an example...

=Demo: Binding A Class in just Moments=

{{{
//-----------------------------------
// My favourite debugging mechanism...
#define CERR std::cerr << __FILE__ << ":" << \
        std::dec << __LINE__ << ":" <<__FUNCTION__ << "(): "

//-----------------------------------
// Required header(s):
#include "v8/convert/ClassCreator.hpp"

// Convenience typedef:
namespace cv = v8::convert;

//-----------------------------------
// The type we want to bind to v8.
struct MyType
{
    MyType() {
        CERR << "MyType::MyType() @ "<<this<<'\n';
    }
    MyType( int i, double d ) {
        CERR << "MyType::MyType("<<i<<", "<<d<<") @ "<<this<<'\n';
    }
    MyType( char const * str ) {
        CERR << "MyType::MyType("<<str<<") @ "<<this<<'\n';
    }
    MyType( v8::Arguments const & argv ) {
        CERR << "MyType::MyType("<<argv.Length()<<" arg(s)) @ "<<this<<'\n';
    }
    ~MyType() {
        CERR << "MyType::~MyType() @ "<<this<<'\n';
    }
    
    // Ctors we want to bind to v8 (there are several other ways to do this):
    typedef cv::Signature<MyType (
        cv::CtorForwarder<MyType *()>,
        cv::CtorForwarder<MyType *(char const *)>,
        cv::CtorForwarder<MyType *( int, double )>,
        cv::CtorForwarder<MyType *( v8::Arguments const &)>
    )> Ctors;

    // Function we want visible to JS:
    int func( double ) { return 42; }
};

// A non-member function which we want to bind as a member of MyType.
// See below for how we get the native 'this' object.
void non_member_func( v8::Arguments const & argv );

//-----------------------------------
// Policies used by cv::ClassCreator (it also has others)...
namespace v8 { namespace convert {

    // The policy which tells ClassCreator how to instantiate and
    // destroy native objects.
    template <>
    class ClassCreator_Factory<MyType>
     : public ClassCreator_Factory_CtorArityDispatcher< MyType, MyType::Ctors >
    {};

    // A JSToNative specialization which makes use of the plumbing
    // installed by ClassCreator. This is required so that
    // CastFromJS<MyType>() will work, as the JS/native binding process
    // requires that we be able to convert (via CastFromJS()) a JS-side
    // MyType object to a C++-side MyType object.
    template <>
    struct JSToNative< MyType > : JSToNative_ClassCreator< MyType >
    {};
}}

//-------------------------
// Because non_member_func() uses CastFromJS<MyType>(), it must be defined
// AFTER JSToNative<MyType> is declared, or the wrong specialization
// of JSToNative will likely be used! If we're lucky it will fail to
// compile. If we're unlucky it will cause a link-time error.
// If we do this in the right order then it will compile and link
// just fine.
void non_member_func( v8::Arguments const & argv )
{
    MyType * self = cv::CastFromJS<MyType>( argv.This() );
    if( ! self ) {
        cv::Toss("Could not find native MyType 'this' pointer!");
        // ^^^ that throws a JS-side exception.
        return;
    }
    ....
}


//-----------------------------------
// Ultra-brief ClassCreator demo. See ConvertDemo.?pp for MUCH more.
void bind_MyType( v8::Handle<v8::Object> dest )
{
    typedef cv::ClassCreator<MyType> CC;
    CC & cc(CC::Instance());
    cc
        ("destroy", CC::DestroyObjectCallback)
        ("func", cv::MethodToInCa<MyType, int (double),
                                  &MyType::func>::Call)
        ("nonMember", cv::FunctionToInCa<
                          void (v8::Arguments const &),
                          non_member_func >::Call )
        .AddClassTo( "MyType", dest );

    // Real-life issue: if this function _might_ be called multiple
    // times in one app, we have to do a small bit more work to avoid
    // duplicate initialization. But that normally is not the case.
}
}}}

While there are lots of possibilities to customize the class-binding process, what is shown above is all that's needed for the basic cases. We generally do not have to modify the to-be-bound classes, but we often (due to differences in how C++ and JS see the world) have to write additional bits of shim/glue code to make specific bindings possible or more flexible.

If we simply construct/destruct a few of them from JS code:

{{{
(new MyType()).destroy();
(new MyType("hi")).destroy();
(new MyType(1,2.3)).destroy();
(new MyType(1,2,3,4,5)).destroy();
}}}

We will see something like:

{{{
demo.cpp:184:MyType(): MyType::MyType() @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:192:MyType(): MyType::MyType(hi) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:188:MyType(): MyType::MyType(1, 2.3) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:196:MyType(): MyType::MyType(5 arg(s)) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
}}}

Notice that the system's memory allocator re-allocated each new instance at the same address as the previously destroyed one. That is a mere fluke of the memory manager, and not a well-defined behaviour.

Real-world examples: the [http://code.google.com/p/v8-juice/source/browse/#svn/convert/addons addons directory] of the source tree contains several complete, non-trivial examples of custom bindings, e.g. [JSPDO], [V8Convert_Socket], and [V8Convert_ByteArray ByteArray].