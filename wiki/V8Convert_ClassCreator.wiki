#summary V8Convert ClassCreator class-binding mechanism
#labels Phase-UserDocs,Topic-JS-API

[V8Convert]'s `ClassCreator` API is an easy-to-use template-based mechanism for binding native classes to JS.

Let's just jump straight to the code...

=Demo: Binding A Class in just Moments=

{{{
//-----------------------------------
// My favourite debugging mechanism...
#define CERR std::cerr << __FILE__ << ":" << \
        std::dec << __LINE__ << ":" <<__FUNCTION__ << "(): "

//-----------------------------------
// Required header(s):
#include "v8/convert/ClassCreator.hpp"

// Convenience typedef:
namespace cv = v8::convert;

//-----------------------------------
// The type we want to bind to v8.
struct MyType
{
    MyType() {
        CERR << "MyType::MyType() @ "<<this<<'\n';
    }
    MyType( int i, double d ) {
        CERR << "MyType::MyType("<<i<<", "<<d<<") @ "<<this<<'\n';
    }
    MyType( char const * str ) {
        CERR << "MyType::MyType("<<str<<") @ "<<this<<'\n';
    }
    MyType( v8::Arguments const & argv ) {
        CERR << "MyType::MyType("<<argv.Length()<<" arg(s)) @ "<<this<<'\n';
    }
    ~MyType() {
        CERR << "MyType::~MyType() @ "<<this<<'\n';
    }
    
    // Ctors we want to bind to v8 (there are several other ways to do this):
    typedef cv::tmp::TypeList<
            //cv::Signature<void ( // this also works.
                cv::CtorForwarder<MyType *()>,
                cv::CtorForwarder<MyType *(char const *)>,
                cv::CtorForwarder<MyType *( int, double )>,
                cv::CtorForwarder<MyType *( v8::Arguments const &)>
            //)
            > Ctors;

    // Function we want visible to JS:
    int func( double ) { return 42; }
};

//-----------------------------------
// Policies used by cv::ClassCreator (it also has others)
namespace v8 { namespace convert {

    template <>
    class ClassCreator_Factory<MyType>
     : public ClassCreator_Factory_CtorForwarder< MyType, MyType::Ctors >
    {};
    template <>
    struct JSToNative< MyType > : JSToNative_ClassCreator< MyType >
    {};
}}

//-----------------------------------
// Ultra-brief ClassCreator demo. See ConvertDemo.?pp for MUCH more.
void bind_MyType( v8::Handle<v8::Object> dest )
{
    typedef cv::ClassCreator<MyType> CC;
    CC & cc(CC::Instance());
    cc
        ("destroy", CC::DestroyObjectCallback)
        ("func", cv::ToInCa<MyType, int (double), &MyType::func>::Call)
        .AddClassTo( "MyType", dest );

    // Real-life issue: if this function _might_ be called multiple
    // times in one app, we have to do a small bit more work to avoid
    // duplicate initialization. But that normally is not the case.
}
}}}

If we simply construct/destruct a few of them from JS code:

{{{
(new MyType()).destroy();
(new MyType("hi")).destroy();
(new MyType(1,2.3)).destroy();
(new MyType(1,2,3,4,5)).destroy();
}}}

We will see something like:

{{{
demo.cpp:184:MyType(): MyType::MyType() @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:192:MyType(): MyType::MyType(hi) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:188:MyType(): MyType::MyType(1, 2.3) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
demo.cpp:196:MyType(): MyType::MyType(5 arg(s)) @ 0x1308ee0
demo.cpp:200:~MyType(): MyType::~MyType() @ 0x1308ee0
}}}

Notice that the system's memory allocator re-allocated each new instance at the same address as the previously destroyed one. That is a fluke of the memory allocator, and not a well-defined behaviour.