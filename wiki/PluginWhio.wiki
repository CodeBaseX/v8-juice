#summary I/O classes for JS
#labels Phase-UserDocs

<wiki:toc max_depth="3" />

=The whio plugin=

The whio plugin adds i/o support to JS. It gets its name from the i/o library it is based on: http://fossil.wanderinghorse.net/repos/whio/

This plugins provides:

  * Class whio.IODevice, which models random-access devices. The back-end supports, in principal, a wide variety of data stores, but v8's class construction mechanism makes it unduly difficult to add the support needed for, e.g., in-memory i/o devices or client-provided back-ends (like [http://fossil.wanderinghorse.net/repos/whefs/ whefs], which i had planned to add bindings for).
  * Classes whio.InStream and whio.OutStream, which model sequential-access devices.

=C++ usage=

When using the plugins API, you don't need to do anything C++-side to use this addon - simply load it as described on [Plugins the plugins page].

=JS usage=

{{{
load_plugin('v8-juice-whio');
var dev = new whio.IODevice("/path/to/file", true); // true= Write-mode
dev.truncate(0);
dev.write("Hi, world!");
...
dev.close();
}}}

See below for the complete class and function list.

==TODOs==

  * Make the vals from whio_rc.XXX available via whio.rc.XXX. whio_rc.SizeTError needs special handling due to (potentially) different sizes in the underlying numeric types.


=JS API for the whio classes=

==IOBase Class==

This class is abstract - it cannot be instantiated directly. However, it does specify several functions of the i/o interface used by its subclasses, and it can be used with `instanceof` to ensure that certain basic i/o operations are implemented.

||*Functions*||*Nodes||
|| `string read(int length)` || Tries to read up to `length` bytes from the input source. Returns the data as a string, and the length of that string will equal the `length` parameter unless EOF is reached or a read error occurs. ||
|| `int write(string data [,int length=data.length])` || Attempts to write `length` bytes of data. Returns the number of bytes actually written, which will be less than `length` on error ||
|| `void close()` || Closes the stream. Do not use the object after calling this. ||
|| `int flush()` || May (or may not) flush any device-specific cache. Returns 0 on success. ||
|| `bool isGood()`  || Returns true if the stream is in a usable state (i.e. there have been no i/o errors). ||
|| *Properties* (read-only) || *Notes* ||
|| `bool canWrite` and `bool canRead`|| Specify whether the object is capable of reading or writing. These are static - set when the device is opened and never changed, so don't use them for error checking. ||

==!InStream Class==

!InStream represents a read-only stream. In additions to the interface defined by IOBase, it has:

|| *Functions* || *Notes* ||
|| `new InStream(string file)` || Opens the given file in read mode. ||
|| `new InStream(IODevice)` || Creates a new stream which acts as a proxy for the given device, which must outlive the new stream. The current cursor position of the IODevice is always used as the current reading point for the stream. ||
|| `int filter( (OutStream|IODevice) dest, Function callback )`  || Described in much more detail below. ||
|| *Properties* (read-only) || *Notes* ||
|| `IODevice ioDevice` || Only for objects created with the `InStream(IODevice)` constructor, this points to the stream's pointed-to device. ||
|| `string fileName` || Only for objects which are associated with a file. ||
|| `bool canWrite` || Always false for !OutStreams. ||
|| `bool canRead` || Always true for !OutStreams. ||

==!OutStream Class==

!OutStream represents a write-only stream. In additions to the interface defined by IOBase, it has:

|| *Functions* || *Notes* ||
|| `new OutStream(string file[, bool truncate=false])` || Opens the given file in write-only mode, truncating it to 0 bytes if truncate is true, otherwise it is appended to ||
|| `new OutStream(IODevice)` || As for InStream(IODevice). If the device is not writable, no write operations on the new object will succeed.||
|| *Properties* (read-only) || *Notes* ||
|| `IODevice ioDevice` || Only for objects created with the `OutStream(IODevice)` constructor, this points to the stream's pointed-to device. ||
|| `string fileName` || Only for objects which are associated with a file. ||
|| `bool canWrite` || Always true for !OutStreams. ||
|| `bool canRead` || Always false for !OutStreams. ||


==IODevice Class==

IODevice represents a random-access i/o device, with read-only or
read/write access. When we say "device", we're normally referring to
a file, but the concept of i/o device is more abstract than that, and
can essentially mean any data source or destination to which we have
random access (the ability to access any point in the data at any
time).

In addition to the interface defined by IOBase, it has:

|| *Functions*  || *Notes* ||
|| `new IODevice(string file,bool writeMode)` || Opens the given file for read and (if writeMode is true) write ||
|| `new IODevice(":memory:" [, int startingSize=0])` || Opens a read/write i/o device which uses RAM as its storage. It starts out at the given size and grows on demand. ||
|| `new IODevice(IODevice,int lower,int upper)`|| Creates a new IODevice which acts as a proxy for a subset of the original device's range. This is described in more detail below. The parent device must outlive the new device. ||
|| `int error()` || Returns a platform-specific non-0 value if the device has an error state. ||
|| `int clearError()` || Tries to clear any error state and EOF marker. Returns 0 on success. ||
|| `bool eof()` || Returns true if the device is at (or past) its EOF. ||
|| `int tell()` || Returns the current position within the underlying device. ||
|| `int seek(int offset[, int whence=IOBase.SEEK_SET])` || Sets the current position to offset, relative to whence, which must be one of `whio.IOBase.SEEK_SET`, `whio.IOBase.SEET_CUR`, or `whio.IOBase.SEEK_END`. Returns the new position. ||
|| `int flush()` || Tries to flush any existing write data, if applicable. Some device types might to other handling here. Returns 0 on success. ||
|| `int truncate(int length)` || Truncates the device to the given length. Returns 0 on success. ||
|| `int size()` || Returns the current size of the device. ||
|| `int rewind()`|| Rewinds the internal device pointer. Returns 0 on success. ||
|| `int filter( (OutStream|IODevice) dest, Function callback )`  || Described in much more detail below. ||
|| *Properties* (read-only) || *Notes* ||
|| `IODevice ioDevice` || Only for devices created with the `IODevice(IODevice,int,int)` constructor, this points to the subdevice's pointed-to device. ||
|| `string fileName` || Only for objects which are associated with a file. ||


===SEEK_SET and friends===

`whio.IODevice.seek()` is semantically identical to the C function `fseek()`, and requires a second argument with one of these values:

  * `whio.IOBase.SEEK_SET` means to move to that absolute position.
  * `whio.IOBase.SEEK_CUR` means to move relative to the current position.
  * `whio.IOBase.SEEK_END` means to move relative to the end of the device.

they are analogous to the C-standard constants of the same names, and are described in the man pages for `fseek()`.

===Subdevices===

The IODevice class has a constructor with the signature `new IODevice(IODevice dev,int lower, int upper)` which used to create "subdevices". A subdevice is a proxy which wraps up a certain range of bytes inside of another IODevice object. This is covered in gross detail in the source file [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/plugins/whio/whio_amalgamation.h whio_amalgamation.h] (search for "subdev_create"), and here's a short demonstration:

Here's one explanation of what subdevices are for:

Consider an IODevice pointing to 100 bytes of storage (somewhere - we don't care where). We can create a subdevice which fences off some amount of that storage. The subdevice is a full-fledged i/o device, but it cannot read or write outside of the bounds it is assigned to.

For example:

{{{
var origin = new whio.IODevice(":memory:");
origin.write("012345679"); // 10 bytes long
var subdev = new whio.IODevice(origin, 4, 7 ); // fence bytes [4,7)
subdev.write("abcdefghij"); // will only write first 3 bytes
origin.rewind();
print(origin.read(10));
subdev.close();
origin.close();
}}}

The output of that script is:
{{{
0123abc79
}}}

Note that the upper bound is equivalent to EOF, or "one past the end", and is not accessible to the subdevice.

Subdevices have some obscure uses, but probably not many which JS applications can make use of.

Subdevices also get an extra function:

|| `int rebound( int lower, int upper )` || Changes the subdevice's lower and upper bounds, relative to the parent. Returns 0 on success. ||

And a new property:

|| `IODevice ioDevice` || This points to the subdevice's pointed-to device. ||


==Error reporting==

The i/o classes are based on an abstract C API. That API uses numeric
error codes or null values to indicate errors, and this library
normally passed on errors from the C API directly back to the
caller. Errors which happen at the JS level, as opposed to the C
level, are reported via exceptions. All of the constructors will throw
if they cannot open their underlying device or stream.

For example, a call to `read(20)` which can only read 13 bytes will
tell us so by returning the number 13, but calling `read()` would trigger an
exception because there is no sensible default value to pass on to the C
API.


=Tips and tricks=


==stdin and stdout==

On Unix platforms you can open standard input and output like this:

{{{
var stdout = new whio.OutStream("/dev/stdout");
var stdin = new whio.InStream("/dev/stdin");
stdout.write("hi, world!\n");
}}}

Note, however, that you shouldn't mix such usage with, e.g. `print()`, or other routines which read/write stdin/stdout, as that may garble your output. Note that calling `close()` on such devices will not close the stdin/stdout associated with the application.

==Use in-memory IODevices as buffers==

You don't need files to use IODevices:

{{{
var dev = new whio.IODevice(":memory:");
}}}

Creates an i/o device which uses RAM as storage, growing as necessary. It works just like a file-based i/o device, and can be used to buffer arbitrary data in memory. To specify a starting size of the device, pass it as the optional second parameter.

While it may not be immediately obvious, this is one easy way to buffer large amounts of text for later output, and "should" be more efficient than using string concatenation to build up very large strings.

If you want to ensure sequential, write-only access to a buffer until you are ready to send it, simply wrap up the IODevice in an !OutStream using `new OutStream(myDevice)`.

==Filtering a stream==

This library his very basic support for stream filtering. Not because
it might actually be useful, but because i thought it'd be interesting to code.

Only !InStreams and IODevices can be filtered, and they get an extra member
method called `filter()`. It has the following signature:

{{{
int filter( OStream|IODevice target,
            Function callback
           [, mixed userData = undefined );
}}}

       The callback signature is:

{{{
int callback(OutStream out,
             string data,
             bool isEnd,
             mixed userData );
}}}

filter() reads the 'this' object until EOF, in blocks of an
unspecified size. Each block is passed to the callback function,
which is presumed to do some sort of filtering on the data.

filter() returns the total number of bytes it thinks where
consumed. This number depends on the callback returning valid
values. In general, no assumptions can be made about the state of the
two streams on error.  On success, this stream will be at EOF.

The callback should:

Perform any translation of the input data it wants to do and
write it out to the destination stream. If it cannot
(e.g. target not writable, or write fails), it should throw.

Return the number of bytes consumed (not output, which might
be very different). On success, data.length should be returned,
and any other value will cause filter() to abort. When
returning an error value, you must simply ensure that it is
some value other than data.length. Zero (0) is only an error when
data.length is not 0.

Be prepared to be called multiple times, as the data is read
in blocks of an unspecified size. If the callback needs persistent data, it can be
passed as the third argument to filter() and the callback will
t it.

If the isEnd parameter is true then this will be the last call for
this filter loop. If needed, the callack can check this and perform
any necessary actions (e.g. flushing a zlib stream, for example).
It IS possible that the callback gets called with an empty data
parameter and (isEnd==true), which simply means the last call to
read data returned 0 bytes (that will only happen on a zero-byte input source or when reading ends exactly on a block boundary).

The callback must not close the output destination.

Below is a rather long example of using filter(). filter() isn't as complex
to use as this example implies, but this was test code while i was
implementing filter(), so it shows more than most would need to do.

{{{
function tryStreamFilter()
{
    // callback for use with filter()
    var cb = function(out,data,isEnd,udata) {
        if( 0 == data.length ) return 0;
	udata.hits += 1;
        var xl = data.replace(/([1357])/g,'$1*'); // some arbitrary transformation
	var rc = out.write(xl,xl.length);
	if( rc != xl.length )
	{
	    throw new Error("Requested write of "+xl.length+" but got only "+rc+" :(!");
	}
	if( isEnd ) out.write("\n",1);
	return data.length;
    };
    var dev = new whio.IODevice(":memory:");
    for( var i = 0; i < 10; ++i )
    {
	dev.write("0123456789");
    }
    var os = new whio.OutStream("/dev/stdout");
    dev.rewind();
    var is = new whio.InStream(dev);
    print('dev =',dev);
    print('os =',os);
    print('is =',is);
    os.write("filter() test:\n");
    var ud = {hits:0,lastIn:0};
    var ex = null;
    try
    {
	dev.filter(os, cb, ud);
	dev.rewind();
	is.filter(os, cb, ud);
	//is.filter(is, cb, ud); // should throw
	//dev.filter(is, cb, ud); // should throw
    }
    catch(e) { ex = e; }
    print('userData.lastIn='+ud.lastIn, 'userData.hits='+ud.hits);
    is.close();
    os.close();
    dev.close();
    if( ex ) throw ex;
}
tryStreamFilter();
}}}