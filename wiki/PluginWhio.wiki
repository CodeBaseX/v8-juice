#summary I/O device bindings for JS
#labels Phase-UserDocs

<wiki:toc max_depth="3" />

=The whio plugin=

The whio plugin adds i/o support to JS. It gets its name from the i/o library it is based on: http://fossil.wanderinghorse.net/repos/whio/

This plugins provides:

  * Class whio.IODevice, which models random-access devices. The back-end supports, in principal, a wide variety of data stores, but v8's class construction mechanism makes it unduly difficult to add the support needed for, e.g., in-memory i/o devices or client-provided back-ends (like [http://fossil.wanderinghorse.net/repos/whefs/ whefs], which i had planned to add bindings for).
  * Classes whio.InStream and whio.OutStream, which model sequential-access devices.

=C++ usage=

When using the plugins API, you don't need to do anything C++-side to use this addon - simply load it described [Plugins on the plugins wiki page].

=JS usage=

{{{
load_plugin('v8-juice-whio');
var dev = new whio.IODevice("/path/to/file", true); // true= Write-mode
dev.truncate(0);
dev.write("Hi, world!");
...
dev.close();
}}}

See below for the complete class and function list.

==TODOs==

  * Make the vals from whio_rc.XXX available via whio.rc.XXX. whio_rc.SizeTError needs special handling due to (potentially) different sizes in the underlying numeric types.


=JS API for the whio classes=



==!InStream Class==

InStream represents a read-only stream.

|| Function or Property || Notes ||
|| `new InStream(string file)` || Opens the given file in read mode. ||
|| `new InStream(IODevice)` || Creates a new stream which acts as a proxy for the given device, which must outlive the new stream. The current cursor position of the IODevice is always used as the current reading point for the stream. ||
|| `string read(int length)` || As for whio.IODevice.read() ||
|| `int write(string data [,int lenght])` || Throws an exception - InStreams cannot write ||
|| `void close()` || As for whio.IODevice.close() ||
|| `int flush()` || As for whio.IODevice.flush() ||
|| `bool isGood()`  || Returns true if the stream is in a usable state. ||
|| `IODevice ioDevice` || Only for objects created with the InStream(IODevice) constructor, this points to the subdevice's pointed-to device. ||


==!OutStream Class==

OutStream represents a write-only stream.

|| Function or Property || Notes ||
|| `new OutStream(string file[, bool truncate=false])` || Opens the given file in write-only mode, truncating it to 0 bytes if truncate is true, otherwise it is appended to ||
|| `new OutStream(IODevice)` || As for InStream(IODevice). If the device is not writable, no write operations on the new object will succeed.||
|| `string read(int length)` || Throws an exception - OutStreams cannot read. ||
|| `int write(string data [,int lenght])` || As for whio.IODevice.write() ||
|| `void close()` || As for whio.IODevice.close() ||
|| `int flush()` || As for whio.IODevice.flush() ||
|| `bool isGood()`  || As for whio.InStream.isGood() ||
|| `IODevice ioDevice` || Only for objects created with the OutStream(IODevice) constructor, this points to the subdevice's pointed-to device. ||


==IODevice Class==

IODevice represents a random-access i/o device, with read-only or read/write access. It is modelled very closely on conventional C-based APIs and will be familiar to anyone who's worked with any of them.

|| Function or Property  || Notes ||
|| `new IODevice(string file,bool writeMode)` || Opens the given file for read and (if writeMode is true) write ||
|| `new IODevice(":memory:" [, int startingSize=0])` || Opens a read/write i/o device which uses RAM as its storage. It starts out at the given size and grows on demand. ||
|| `new IODevice(IODevice,int lower,int upper)`|| Creates a new IODevice which acts as a proxy for a subset of the original device's range. This is described in more detail below. The parent device must outlive the new device. ||
|| `int write(string[,length=string.lenght`) || Writes up to length bytes. Returns number of bytes written. ||
|| `string read(length)` || Reads, at most, length bytes and returns the result as a string ||
|| `void close()` || Closes the device. Do not use the object after calling this. ||
|| `int error()` || Returns a platform-specific non-0 value if the device has an error state. ||
|| `int clearError()` || Tries to clear any error state and EOF marker. Returns 0 on success. ||
|| `bool eof()` || Returns true if the device is at (or past) its EOF. ||
|| `int tell()` || Returns the current position within the underlying device. ||
|| `int seek(int offset, int whence)` || Sets the current position to offset, relative to whence, which must be one of `whio.IODevice.SEEK_SET`, `whio.IODevice.SEET_CUR`, or `whio.IODevice.SEEK_END`. Returns the new position. ||
|| `int flush()` || Tries to flush any existing write data. Returns 0 on success. ||
|| `int truncate(int length)` || Truncates the device to the given length. Returns 0 on success. ||
|| `int size()` || Returns the current size of the device. ||
|| `int rewind()`|| Rewinds the internal device pointer. Returns 0 on success. ||
|| `IODevice ioDevice` || Only for devices created with the IODevice(IODevice,int,int) constructor, this points to the subdevice's pointed-to device. ||


===SEEK_SET and friends===

`whio.IODevice.seek()` is semantically identical to the C function `fseek()`, and requires a second argument with one of these values:

  * `whio.IODevice.SEEK_SET` means to move to that absolute position.
  * `whio.IODevice.SEEK_CUR` means to move relative to the current position.
  * `whio.IODevice.SEEK_END` means to move relative to the end of the device.

they are analogous to the C-standard constants of the same names, and are described in the man pages for `fseek()`.

===Subdevices===

The IODevice class has a constructor with the signature `new IODevice(IODevice dev,int lower, int upper)` which used to create "subdevices". A subdevice is a proxy which wraps up a certain range of bytes inside of another IODevice object. This is covered in gross detail in the source file [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/plugins/whio/whio_amalgamation.h whio_amalgamation.h] (search for "subdev_create"), and here's a short demonstration:

Here's one explanation of what subdevices are for:

Consider an IODevice pointing to 100 bytes of storage (somewhere - we don't care where). We can create a subdevice which fences off some amount of that storage. The subdevice is a full-fledged i/o device, but it cannot read or write outside of the bounds it is assigned to.

For example:

{{{
var origin = new whio.IODevice(":memory:");
origin.write("012345679"); // 10 bytes long
var subdev = new whio.IODevice(origin, 4, 7 ); // fence bytes [4,7)
subdev.write("abcdefghij"); // will only write first 3 bytes
origin.rewind();
print(origin.read(10));
subdev.close();
origin.close();
}}}

The output of that script is:
{{{
0123abc79
}}}

Note that the upper bound is equivalent to EOF, or "one past the end", and is not accessible to the subdevice.

Subdevices have some obscure uses, but probably not many which JS applications can make use of.

Subdevices also get an extra function:

|| `int rebound( int lower, int upper )` || Changes the subdevice's lower and upper bounds, relative to the parent. Returns 0 on success. ||

And a new property:

|| `IODevice ioDevice` || This points to the subdevice's pointed-to device. ||

=Tips and tricks=

==stdin and stdout==

On Unix platforms you can open standard input and output like this:

{{{
var stdout = new whio.OutStream("/dev/stdout");
var stdin = new whio.InStream("/dev/stdin");
stdout.write("hi, world!\n");
}}}

Note, however, that you shouldn't mix such usage with, e.g. `print()`, or other routines which read/write stdin/stdout, as that may garble your output. Note that calling `close()` on such devices will not close the stdin/stdout associated with the application.

==Use in-memory IODevices as buffers==

You don't need files to use IODevices:

{{{
var dev = new whio.IODevice(":memory:");
}}}

Creates an i/o device which uses RAM as storage, growing as necessary. It works just like a file-based i/o device, and can be used to buffer arbitrary data in memory. To specify a starting size of the device, pass it as the optional second parameter.

While it may not be immediately obvious, this is one easy way to buffer large amounts of text for later output, and "should" be more efficient than using string concatenation to build up very large strings.

If you want to ensure sequential, write-only access to a buffer until you are ready to send it, simply wrap up the IODevice in an !OutStream using `new OutStream(myDevice)`.