#summary I/O classes for JS
#labels Phase-UserDocs,Topic-Plugins,Topic-JS-API

*Achtung #1:* these docs are for the current version in the subversion
source tree (i document here as changes are made). If you are using an "older" version,
i recommend [http://code.google.com/p/v8-juice/source/browse/wiki/PluginWhio.wiki searching through the subversion repo] for a version of this page which is
closer to the version you're working with (follow that link, and there are options to browse all versions).

*Achtung #2:* It has [http://groups.google.com/group/v8-users/browse_thread/thread/1621beb71d65e6fa/2883be6ddd10cddd come to my attention] that using this API to read and write non-ASCII data may (and eventually will) produce undefined results (due to how v8 internally stores and translates strings). *You Have Been Warned.*

=The whio I/O plugin=

The whio plugin adds object-oriented i/o support to v8 JavaScript applications.

<wiki:toc max_depth="3" />


==About==
whio gets its name from the i/o library it is based on:

http://fossil.wanderinghorse.net/repos/whio/

That library is provided with this plugin, and need not be installed separately.

This plugins provides the following features:

  * Classes `whio.InStream` and `whio.OutStream`, which model sequential-access devices. These are your general-purposes i/o objects and are suitable for most work even though they are limited to either reading or writing.
  * Class `whio.IODevice` controls access to an underlying random-acces device (e.g. a file or in-memory buffer). The back-end supports, in principal, a wide variety of data stores.


=C++ usage=

When using the plugins API, you don't need to do anything C++-side to
use this addon - simply load it as described on [Plugins the plugins page].

=JS usage=

{{{
load_plugin('v8-juice-whio');
var dev = new whio.IODevice("/path/to/file", true); // true= Write-mode
dev.truncate(0);
dev.write("Hi, world!");
...
dev.close();
}}}

See below for the complete class and function list.

==TODOs==

  * Make the vals from whio_rc.XXX available via whio.rc.XXX. whio_rc.SizeTError needs special handling due to (potentially) different sizes in the underlying numeric types.

=JS API for the whio classes=

==IOBase Class==

This class is abstract - it cannot be instantiated directly. However, it does specify several functions of the i/o interface used by its subclasses, and it can be used with `instanceof` to ensure that a given object has the most basic i/o operations.

The API for this class includes any routines which are common amongst the `InStream`, `OutStream`, and `IODevice` classes, but those classes sometimes provide their own implementations for these functions.

||*Functions*||*Nodes||
|| `string read(int length)` || Tries to read up to `length` bytes from the input source. Returns the data as a string, and the length of that string will equal the `length` parameter unless EOF is reached or a read error occurs. ||
|| `int write(string data [,int length=data.length])` || Attempts to write `length` bytes of data. Returns the number of bytes actually written, which will be less than `length` on error ||
|| `void close()` || Closes the stream. Do not use the object after calling this. ||
|| `int flush()` || May (or may not) flush any device-specific cache. Returns 0 on success. ||
|| `bool isGood()`  || Returns true if the object is in a usable state (i.e. there have been no i/o errors). ||
|| *Properties* (read-only) || *Notes* ||
|| `bool canWrite` and `bool canRead`|| Specify whether the object is capable of reading or writing. These are static - set when the device is opened and never changed, so don't use them for error checking. ||

==!InStream Class==

!InStream represents a read-only stream. In addition to the interface defined by IOBase, it has:

|| *Functions* || *Notes* ||
|| `new InStream(string file)` || Opens the given file in read mode. ||
|| `new InStream(IODevice)` || Creates a new stream which acts as a proxy for the given device, which must outlive the new stream. The current cursor position of the IODevice is always used as the current reading point for the stream. ||
|| *Properties* (read-only) || *Notes* ||
|| `IODevice ioDevice` || Only for objects created with the `InStream(IODevice)` constructor, this points to the stream's pointed-to device. ||
|| `string fileName` || Only for objects which are associated with a file. ||
|| `bool canWrite` || Always false for !OutStreams. ||
|| `bool canRead` || Always true for !OutStreams. ||

==!OutStream Class==

!OutStream represents a write-only stream. In additions to the interface defined by IOBase, it has:

|| *Functions* || *Notes* ||
|| `new OutStream(string file[, bool truncate=false])` || Opens the given file in write-only mode, truncating it to 0 bytes if truncate is true, otherwise it is appended to ||
|| `new OutStream(IODevice)` || As for InStream(IODevice). If the device is not writable, no write operations on the new object will succeed.||
|| *Properties* (read-only) || *Notes* ||
|| `IODevice ioDevice` || Only for objects created with the `OutStream(IODevice)` constructor, this points to the stream's pointed-to device. ||
|| `string fileName` || Only for objects which are associated with a file. ||
|| `bool canWrite` || Always true for !OutStreams. ||
|| `bool canRead` || Always false for !OutStreams. ||


==IODevice Class==

IODevice represents a random-access i/o device, with read-only or
read/write access. When we say "device", we're normally referring to
a file, but the concept of i/o device is more abstract than that, and
can essentially mean any data source or destination to which we have
random access (the ability to access any point in the data at any
time).

In addition to the interface defined by IOBase, it has:

|| *Functions*  || *Notes* ||
|| `new IODevice(string file,bool writeMode)` || Opens the given file for read and (if writeMode is true) write ||
|| `new IODevice(":memory:" [, int startingSize=0])` || Opens a read/write i/o device which uses RAM as its storage. It starts out at the given size and grows on demand. ||
|| `new IODevice(IODevice,int lower,int upper)`|| Creates a new IODevice which acts as a proxy for a subset of the original device's range. This is described in more detail below. The parent device must outlive the new device. ||
|| `int error()` || Returns a platform-specific non-0 value if the device has an error state. ||
|| `int clearError()` || Tries to clear any error state and EOF marker. Returns 0 on success. ||
|| `bool eof()` || Returns true if the device is at (or past) its EOF. ||
|| `int tell()` || Returns the current position within the underlying device. ||
|| `int seek(int offset[, int whence=IOBase.SEEK_SET])` || Sets the current position to offset, relative to whence, which must be one of `whio.IOBase.SEEK_SET`, `whio.IOBase.SEET_CUR`, or `whio.IOBase.SEEK_END`. Returns the new position. ||
|| `int flush()` || Tries to flush any existing write data, if applicable. Some device types might to other handling here. Returns 0 on success. ||
|| `int truncate(int length)` || Truncates the device to the given length. Returns 0 on success. ||
|| `int size()` || Returns the current size of the device. ||
|| `int rewind()`|| Rewinds the internal device pointer. Returns 0 on success. ||
|| *Properties* (read-only) || *Notes* ||
|| `IODevice ioDevice` || Only for devices created with the `IODevice(IODevice,int,int)` constructor, this points to the subdevice's pointed-to device. ||
|| `string fileName` || Only for objects which are associated with a file. ||
|| `bool canWrite` || Value depends on how the device was opened. It is not always possible for the stream opener to know if a given stream supports writing (e.g. stdin), and this value may be set incorrectly for those cases. Writing to such a stream will cause the normal write failure, nothing catastrophic. ||
|| `bool canRead` || Value depends on how the device was opened. For files this value is always true, even if the file being opened cannot support reading (e.g. stdout). That is because the open() routines don't have enough information to know that. In a case like that, reading would fail in the normal manner. ||


===SEEK_SET and friends===

`whio.IODevice.seek()` is semantically identical to the C function `fseek()`, and requires a second argument with one of these values:

  * `whio.IOBase.SEEK_SET` means to move to that absolute position.
  * `whio.IOBase.SEEK_CUR` means to move relative to the current position.
  * `whio.IOBase.SEEK_END` means to move relative to the end of the device.

they are analogous to the C-standard constants of the same names, and are described in the man pages for `fseek()`.

===Subdevices===

The IODevice class has a constructor with the signature `new IODevice(IODevice dev,int lower, int upper)` which used to create "subdevices". A subdevice is a proxy which wraps up a certain range of bytes inside of another IODevice object. This is covered in gross detail in the source file [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/plugins/whio/whio_amalgamation.h whio_amalgamation.h] (search for "subdev_create"), and here's a short demonstration:

Here's one explanation of what subdevices are for:

Consider an IODevice pointing to 1000 bytes of storage (somewhere - we don't care where). We can create a subdevice which fences off some amount of that storage. The subdevice is a full-fledged i/o device, but it cannot read or write outside of the bounds it is assigned to.

For example:

{{{
var origin = new whio.IODevice(":memory:");
origin.write("012345679"); // 10 bytes long
var subdev = new whio.IODevice(origin, 4, 7 ); // fence bytes [4,7)
subdev.write("abcdefghij"); // will only write first 3 bytes
origin.rewind();
print(origin.read(10));
subdev.close();
origin.close();
}}}

The output of that script is:
{{{
0123abc79
}}}

Note that the upper bound is equivalent to EOF, or "one past the end", and is not accessible to the subdevice.

Subdevices have some obscure uses, but probably not many which JS
applications can make use of. They were originally designed to
partition off access to various internal areas of
[http://fossil.wanderinghorse.net/repos/whefs/ an embedded filesystem library].

Subdevices get an extra function compared to other IODevices:

|| `int rebound( int lower, int upper )` || Changes the subdevice's lower and upper bounds, relative to the parent. Returns 0 on success. ||

And a new property:

|| `IODevice ioDevice` || This points to the subdevice's pointed-to device. ||


==Error reporting==

The i/o classes are based on an abstract C API. That API uses numeric
error codes or null values to indicate errors, and this library
normally passed on errors from the C API directly back to the
caller. Errors which happen at the JS level, as opposed to the C
level, are reported via exceptions. All of the constructors will throw
if they cannot open their underlying device or stream.

For example, a call to `read(20)` which can only read 13 bytes will
tell us so by returning the number 13, but calling `read()` with no
arugments would trigger an exception because there is no sensible
default value to pass on to the C API.

=Tips and tricks=


==stdin and stdout==

On Unix platforms you can open standard input and output like this:

{{{
var stdout = new whio.OutStream("/dev/stdout");
var stdin = new whio.InStream("/dev/stdin");
stdout.write("hi, world!\n");
}}}

Note, however, that you shouldn't mix such usage with, e.g. `print()`, or other routines which read/write stdin/stdout, as that may garble your output (depending on the buffering used by the underlying interface, e.g. `std::cout` vs. `printf()`). Calling `close()` on such devices will _not_ close the stdin/stdout associated with the application.

==Use in-memory IODevices as buffers==

You don't need files to use IODevices:

{{{
var dev = new whio.IODevice(":memory:");
}}}

Creates an i/o device which uses RAM as storage, growing as necessary. It works just like a file-based i/o device, and can be used to buffer arbitrary data in memory. To specify a starting size of the device, pass it as the optional second parameter. Multiple in-memory devices can be created, but each has its own memory despite having the same name of `":memory:"`.

While it may not be immediately obvious, this is one easy way to buffer large amounts of text for later output, and "should" be more efficient than using string concatenation to build up very large strings. (See the big ugly warning at the top of this page regarding writing binary data this way!)

If you want to ensure sequential, write-only access to a buffer until you are ready to send it, simply wrap up the IODevice in an !OutStream using `new OutStream(myDevice)`.