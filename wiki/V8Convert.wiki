#summary The v8::convert sub-project
#labels Phase-UserDocs,Topic-CPlusPlus,Featured

<wiki:toc max_depth=4></wiki:toc>

= v8::convert =

Source code: [http://code.google.com/p/v8-juice/source/browse/#svn/convert] (see [http://code.google.com/p/v8-juice/source/checkout this link] for checkout instructions.)

The `v8::convert` API is a spin-off of the core-most components of the v8-juice library. It has a templates-heavy, header-only implementation and has no 3rd-party dependencies beyond the STL and whatever v8 needs. v8-convert can be used in conjunction with other v8 libraries like [https://github.com/tsa/vu8 vu8] and [http://www.nodejs.org/ nodejs]. It's main features/focus are:

  * Converting between v8 Value handles and "native types" using a generic interface. This allows us to write generic algorithms which convert between JS/C++ without having to know the exact types we're dealing with.  The basic POD types and some STL types are supported out of the box and plugging in one's own types is normally quite simple.
  * Converting free- and member functions into `v8::InvocationCallback` functions. These generated functions convert the !JavaScript-originated function arguments into native counterparts, forward the data to the original native function, and convert the return values back to something JS can use. (The `void` return type is translated to the `undefined` JS value.)
  * Binding JS object properties to native shared or member properties or accessor/mutator functions/methods.

The first two core features give us all we need in order to be able to bind near-arbitrary C/C++ functions with !JavaScript, insofar as cross-language calling conventions and type conversions allow us to do so. The last feature is really just "sugar" (but also quite convenient at times).

While these features are easily summed up in a short list, their broader implications are quite large. The ability to convert functions from one signature to another (at compile time, by the way) has proven to be deceptively powerful, allowing users to bind new functions to v8 with unprecedented ease. We can combine this with template meta-programming techniques to do weird things like combine multiple native functions into a single `InvocationCallback` function which dispatches to the proper native function based on the number of arguments (see the examples of argument overload later on down this page).

For cases where the "automatic" function-to-!InvocationCallback conversions are not possible or not suitable, the type-conversion API can still simplify the implementation of custom `v8::InvocationCallback` functions.

All of the conversions are compile-time typesafe where possible and fail gracefully (e.g. using a JS-side exception as opposed to an immediate crash) when such a determination can only be made at runtime.

This code originated as the core-most component of the [http://code.google.com/p/v8-juice v8-juice library]. After a couple years i felt compelled to refactor it into a toolkit usable by arbitrary v8-using clients, doing a bit of cleanup along the way. The eventual intention is that this code will replace the v8::juice::convert code.

The most important functions and types, from a user's perspective, are listed below. Most of the code in this library are internal template specializations which take care of the dirty work. Typical clients won't normally need more than what's described on this page.

A very special thanks goes to James Pike, author of [https://github.com/tsa/vu8 vu8], for his helpful tips on getting function-pointer-style template arguments working. These allow for more readable templates when compared to the v8-juice API.

==Notes about the Namespace==

The library is rooted in the namespace `v8::convert`, but most of the sample code in the wiki (and lots of the real code, for that matter) uses the following namespace alias:

{{{
namespace cv = v8::convert;
}}}

In hindsight, it was "probably not the best idea" to add a sub-namespace of v8, and i "probably should have" used `v8cv` or something similar. If the v8 team ever decides to use the `convert` namespace for themselves, i'm screwed. In that case, v8cv would be my fall-back.

=Converting Types=

The public type conversions API is based on only two functions:

  * `CastToJS<T>()`: converts the given object to a `v8::Handle<v8::Value>`.
  * `CastFromJS<T>()`: converts a v8 value to a `T` (actually `T*` for most non-POD types).

These are very thin wrappers around `NativeToJS<>` and `JSToNative<>`, and work identically to the v8-juice APIs with the same names (see [ConvertingTypes]). A few special-case overloads also exist to avoid call ambiguities in some cases or to cover special cases (most notably those taking (`char *`) and `v8::InvocationCallback` arguments).

Using these operations allows us to convert a wide variety of types between JS and C++, and the `NativeToJS<>` and `JSToNative<>` classes give us a way to extend the conversion operations to support custom conversions. This level of abstraction allows us, in turn, to implement all sorts of algorithms which are ignorant of the _types_ they are working on. The function-binding APIs, for example, rely on this for converting function argument and return values to/from JS/C++.

Here's a silly trick we can do with `CastToJS()`:

{{{
v8::Handle<v8::Value>
myInvocationCallback( v8::Arguments const & ) {
    try {
     ....
    }
    catch( std::exception const & ex ) {
       return cv::CastToJS(ex); // triggers a JS-side exception
    }
}
}}}

=Implementing Custom Conversions=

  * `JSToNative<T>`: template to convert JS values to `T` (_almost_ always `T*` for non-POD types).
  * `NativeToJS<T>`: template to convert `T` objects to JS counterparts. Adding this support for client-side types requires adding tooling which maps the native object to a JS instance (or that the bound type hold this information itself).

These work identically to the v8-juice APIs with the same names (see [ConvertingTypes]), the only client-visible difference being that the classes (and thus client-defined specializations) are defined in a different namespace than in v8-juice. Future (post-2010) development in the type conversions API will happen in this copy instead of the `v8::juice` copy.


=Converting Functions to `v8::InvocationCallback`=

Quite possibly the simplest way in the world to convert free functions and member functions to `v8::InvocationCallback` functions is using the `ToInCa<>` template ("!InCa" is short for "!InvocationCallback"):

{{{
v8::InvocationCallback cb;

// A non-const method: int MyType::nonConstMethod(char const *)
cb = cv::ToInCa<MyType, int (char const *), &MyType::nonConstMethod>::Call;

// A const method: int MyType::constMethod(char const *) const
cb = cv::ToInCa<MyType, int (char const *) const, &MyType::constMethod>::Call;
// Note the trailing 'const' qualifier on the function signature!

// A free function: int puts(char const *)
cb = cv::ToInCa<void, int (char const *), ::puts>::Call;
// Functions (not Methods) require 'void' as the first parameter!
}}}

Because these templates _create_ `v8::InvocationCallback` functions at compile-time, they require no dynamically-allocated proxy objects or other hidden memory usage like some binding mechanisms require. The only overhead these templates add is the conversion of arguments/return values to/from JS. The library does as much work as possible at compile time to help detect type-conversion errors early and help avoid extra runtime costs.


The `ToInCa` template is a thin wrapper around three primary class templates:

  * `FunctionToInCa<>`
  * `MethodToInCa<>`
  * `ConstMethodToInCa<>`

By using only those 3 templates (all with identical interfaces) clients can bind
a wide variety of native functions to arbitrary JS objects (where language calling conventions and cross-language type conversions allow).

Support for const- and non-const methods are split into two implementations because some compilers reportedly cannot properly choose differing specializations when the difference is only in constness. (i have only heard of this being a problem on MSVC.) In hindsight, this self-imposed limitation has at times been a hindrance and has caused much unneeded code duplication, and i will probably quit coddling inadequate compilers at some point.

Note that binding to non-static member methods requires (at runtime), that `CastFromJS<T>()` can convert the current JS 'this' object to its native counterpart. See [V8Convert_ClassCreator] for an example of one way to set this up (there are many ways).

==Argument Type Information==

When using `FunctionToInCa` and friends (including `ToInCa`) we can use template techniques to get type information about the arguments if we want to use that for conversion purposes:

{{{
namespace cv = v8::convert;
typedef ToInCa<void, int (char const *,double), my_function> MyFunc;

assert( MyFunc::Arity == 2 ); // number of args the function takes.
typedef cv::SignatureParamAt< MyFunc, 0 >::Type A0; // == (char const *)
typedef cv::SignatureParamAt< MyFunc, 1 >::Type A1; // == double
//typedef cv::SignatureParamAt< MyFunc, 2 >::Type A2; // compile-time error (arg out of bounds)
}}}

We can use further templating techniques to do things like choose different code paths based on that type information, as in this rather contrived example which changes `int64_` to `double` (v8 does not internally support 64-bit integers):

{{{
namespace tmp = cv::tmp;
typedef tmp::IfElse< tmp::SameType<int64_t,ArgType0>::Value,
                     double,
                     ArgType0
                   >::Type NumericType;
}}}

Template gurus will certainly come up with new and original ways to use and abuse this feature.

== Examples ==

Some examples of binding functions and methods:

{{{
#include <cstdio> // puts()
...
namespace cv = v8::convert;

v8::InvocationCallback cb; // v8's generic callback function interface

// Here's how we can "convert" various native functions to
// v8::InvocationCallback functions:

// Function: int puts(char const *)
cb = cv::FunctionToInCa<
       int (char const *), ::puts
     >::Call;

// Class method: double MyType::multiply(double, double)
cb = cv::MethodToInCa<
       MyType,
       double (double,double),
       &MyType::multiply
     >::Call;

// Const class method:
//    char const * MyType::errorCodeToString(int) const
cb = cv::ConstMethodToInCa<
       MyType,
       char const * (int),
       &MyType::errorCodeToString
     >::Call;

// Here's how we can bind a JS-side garbage-collection-triggering
// function:
cb = cv::ToInCa<void, bool (),v8::V8::IdleNotification>::Call;
}}}

Those examples demonstrate of the public API one needs for converting functions to `v8::InvocationCallback` equivalents! There are some additional templates which add features on top of those, but those are all one really needs for most basic function bindings.

It might be interesting to note that the above functions are _created_, but _not actually called_, by the above code (note that we pass no non-template parameters to them).

== Caveats and Unsupported Functions ==

Some examples of function signatures which _cannot_ (or must not) be converted using this framework:

  * `int func( someType ** )`: pointer-to-pointer cannot be translated generically to JS
  * `int func( void * )`: Giving access to `void *` in JS makes it really easy to crash your apps from script code.
  * `int func(...)`: elipsis lists, `va_list`, and C++0x var-args are not directly supported.
  * !JavaScript has no inherent support for binary data, and v8's string class does not support it. Thus this API must not be used with functions returning binary data (e.g. via `char [const]*`).

Supported, but ill-advised:

  * `anything * func(anything)`: if the function returns dynamically-allocated memory, or transfers ownership of the returned memory to the caller, it _will_ cause a leak unless that memory has been somehow given over to v8 from within that function. That said... when using a class-binding mechanism which creates the native object from JS code and has enough internal plumbing to support an implementation of `NativeToJS<MyType>`, we can in fact make this conversion legal for many client-defined types.

== The (`char [const] *`) Problem ==

Because of issues regarding the ownership and lifetimes of raw C-style string, functions taking `(char const *)` have a few relatively minor limitations:

  * The C-strings _must_ be `NULL` or nul-terminated. It cannot be used with binary data because they are converted to JS strings.
  * Non-const (`char *`) is not supported. We could partially implement it using a proxy, but the changes would get lost on their way back to JS space because the JS calling conventions do not allow us to pass changes to strings back this way.
  * The bound function _must not_ hold the pointer it is passed after it returns. It must either consume or ignore the input, and keep no copy of the pointer itself.
  * The internal conversion process uses `v8::String::Utf8Value`, and "should" be safe for use with functions accepting ASCII or UTF8 input. Behaviour with any other encodings is undefined.
  * If passed a JS `null` or `undefined`, it converts to a literal `NULL`, otherwise it will convert to a string (though possibly empty). This is significant for functions which treat `NULL` different than an empty string (like `strlen()`, which may crash your app if passed `NULL`).

When native functions return (`char const *`), they are converted to v8 Strings, and therefore have the same encoding limitations as for C-string function arguments. A return value of `NULL` is converted to a JS `null`, as opposed to an empty string.


This support allows us to convert functions like the following to `v8::InvocableCallback`s:

{{{
char const * cstring_test( char const * c )
{
    std::cerr << "cstring_test( @"<<(void const *)c
              <<") ["<<(c ? c : "<NULL>")<<"]\n";
    return c;
}

v8::InvocationCallback cb =
   cv::FunctionToInCa<
     char const * (char const *),
     cstring_test
    >::Call;
}}}

If we bind that to JS with the name `cstr`:

{{{
var jstr = "Hi, world!";
jstr = cstr(jstr); print(jstr);
jstr = cstr(undefined); print(jstr);
jstr = cstr(null); print(jstr);
jstr = cstr("Bye, world!"); print(jstr);
}}}

The output looks something like:

{{{
cstring_test( @0x984acbc) [Hi, world!]
Hi, world!
cstring_test( @0) [<NULL>]
null
cstring_test( @0) [<NULL>]
null
cstring_test( @0x984acbc) [Bye, world!]
Bye, world!
}}}

(The fact that the pointer addresses are the same in the first and last calls is a mere fluke of memory re-allocation, and must not be understood to mean that the address is somehow stable across calls.)

==Special Case: `v8::InvocationCallback`-like Functions==

The library provides special support for binding functions which "look like" a `v8::InvocationCallback`. The definition of "looks like" is: the function takes only a single `(v8::Arguments const &)` argument and returns any type.

Such functions are treated like `v8::InvocationCallback` instances, in that they can accept any number of arguments of any type. The return value is converted to a `v8::Handle<v8::Value>` (or to JS `undefined` for `void` returns).

Examples of what we consider to be `v8::InvocationCallback`-like:

{{{
int my_callback( v8::Arguments const & );
void MyType::callback( v8::Arguments const & );
double MyType::constCallback( v8::Arguments const & ) const;
}}}

And we can create `v8::InvocationCallback` functions from them like:

{{{
InvocationCallback cb;

cb = FunctionToInCa< int (Arguments const &),
                     my_callback >::Call;
// Is equivalent to:
cb = ToInCa<void,
            int (Arguments const &),
            my_callback>::Call;


cb = MethodToInCa< MyType,
                   void (Arguments const &),
                   &MyType::callback >::Call;
// Is equivalent to:
cb = ToInCa<MyType,
            void (Arguments const &),
            &MyType::callback>::Call;


cb = ConstMethodToInCa< MyType,
                        double (Arguments const &),
                        &MyType::constCallback >::Call;
// Is equivalent to:
cb = ToInCa<MyType,
            double (Arguments const &) const, // note the trailing 'const'!
            &MyType::constCallback>::Call;
}}}

(Pretty simple, huh?)

Free functions bound this way have a particularly interesting property: if such a function is bound as a member of a `T` native object, we can access the native `this` pointer from inside that function like this:

{{{
int my_callback( v8::Arguments const & argv )
{
   T * self = cv::CastFromJS<T>(argv.This());
   if( !self ) {
       // no native T found. This might or might not
       // be an error, depending on app-specific conditions.
   }
   ...
}
}}}


==Special Case: Overloading based on Arity==

The API has basic support for overloading multiple `InvocationCallback`s based on their arity (the number of arguments they require). We have two approaches to doing this, but only one is shown here (the one which is far easier to use for most cases).

The `InCaOverloadList` template takes a `TypeList` of function binding templates (or something interface-compatible) and combines them into a single `v8::InvocationCallback` function which can dispatch script-side calls to a different native function depending on the number (not the types) of arguments.

It looks like this:

{{{
// Overload 4 variants of a member function:
typedef cv::InCaOverloadList< cv::Signature<void (
        cv::MethodToInCa<T, void (), &T::overload0>,
        cv::MethodToInCa<T, void (int), &T::overload1>,
        cv::MethodToInCa<T, void (int,int), &BoundNative::overload2>,
        cv::MethodToInCa<T, void (v8::Arguments const &), &T::overloadN> // fallback for N args
    )> > MyOverloads;
// Note that the order of the list entries is irrelevant (for _most_ purposes).
// The exception being that one taking v8::Arguments will always be called,
// so it should come at the end of the list (since it overrides any coming
// after it).

// Get the InvocationCallback proxy which does the arity-based dispatching:
v8::InvocationCallback cb = MyOverloads::Call;
}}}

Note that only one line of that code is evaluated at runtime - the rest is all done at compile-time. The above generates a whole family of `v8::InvocationCallback` functions (at least (overload count + 1) of them, though there are a couple others hidden behind the scenes) and combines them into a single `v8::InvocationCallback` dispatcher function, `MyOverloads::Call()`.

There is actually a limit to how many overloads you can provide in a single `InCaOverloadList`, but the lower limit is _at least_ 10 (and the library can be built to support many more than that). (If you're overloading 10+ variants of one function then the design probably needs to be reconsidered!)

In theory the API provides enough type information so that we could (theoretically) build advanced templates which can (theoretically) dispatch based (theoretically) on the types passed in at runtime. It would require some masterful _Template Fu_ and (likely) a boatload of `typedef`s, though. In principal such a construct is similar to templates-based parser generators (e.g. `Boost::Spirit`, and i've written 3 or 5 similar libraries in my time). If we approach it like a parser, with arguments being the tokens, building such dispatchers shouldn't be too conceptually difficult. Something along the lines of "PEG Parser for v8::Arguments." Well, now the challenge has been made. Let's see if it ever gets done.

==Special Case: Non-Convertible Return Types==

Sometimes we want to bind a function which has a return type which we cannot convert to JS. That means we can't bind it (compile errors if we try). There is, however, a half-workaround. If we don't mind simply losing the return value on the way back to JS, we can use `ToInCaVoid<>` to generate an `v8::InvocationCallback` proxy which explicitly does not call `CastToJS()` to convert the return type. The implication of that is that we can then bind it (despite the non-convertible return value), but JS will get the `undefined` value as the result of each call:

{{{
v8::InvocationCallback cb;
cb = cv::ToInCaVoid<void, SomeNonConvertibleType (args...), myFunction>::Call;
// Equivalent to:
cb = cv::FunctionToInCaVoid<SomeNonConvertibleType (args...), myFunction>::Call;
}}}

We can also use that to bind functions whos return types we _could_ convert but don't want to for some reason (e.g. we don't want native error goes going back to JS).

Be careful not to leak resources this way. If dynamically-allocated resources are returned from a function bound this way, they will be irrevocably leaked on every call to the function!

==Special Case: Unlocking the v8 Engine==

Consider this function binding:

{{{
#include <unistd.h> // sleep(), or Sleep(N*1000) on Windows
v8::InvocationCallback cb =
    cv::FunctionToInCa<
       unsigned int (unsigned int), sleep
     >::Call;
}}}

When that callback is called, the calling code is locking v8, meaning that other v8-using threads cannot preempt it. When calling C-level APIs which themselves do not call back into v8, we may instead want to tell v8 that other threads may run. That is done like this:

{{{
... somewhere inside a v8 callback function ...
{
  v8::Unlocker unlock;
  nativeFunction(...);
}
... v8 is locked again here, so we can use v8 again ...
}}}

If the native function will only run very briefly then unlocking will probably be slower than leaving v8 locked, but if the function may run an arbitrarily long amount of time, unlocking it is wise because v8 can then allow other threads to continue instead of blocking while this call holds the v8 lock.

As of the early morning of 20110625, the library includes generic support for optionally telling function bindings that they should unlock v8 for the duration of the native call.

The default value for this option (for any given instantiation of the templates, not globally) depends on several factors but it will normally be enabled. If the function signature involved contains any v8 types then unlocking is disabled and a compile-time assertion is triggered if the client explicitly enables it.

To force a given function/method binding to run in "unlocked" mode, simply pass `true` as the final (optional) argument to `ToInCa` (and friends):

{{{
v8::InvocationCallback cb;

cb = cv::ToInCa<void, int (char const *), ::puts, true >::Call;
// Is equivalent to:
cb = cv::FunctionToInCa<int (char const *), ::puts, true >::Call;

// Class methods are handled the same way:
cb = cv::ToInCa<T, int (double), &T::foo, true>::Call;
cb = cv::ToInCa<T, int (double) const, &T::fooConst, true>::Call;
}}}

*Achtung:* this support has a couple notable gotchas, caveats, and Things One Needs to Know. The ones which immediately come to mind are:

  * A compile-time assertion will be triggered if you pass `true` to enable it and the function cannot, due to one of the types in its signature, be run in unlocked mode. See the `IsUnlockable<>` and `SignatureIsUnlockable<>` API docs for all the gory details.
  * Unlocking tells v8 to perform some threading/mutex-related voodoo about which i know remarkably little. There is a performance hit for this, but it is marginal.
  * _Reacquiring_ the v8 lock after the native function returns can theoretically take arbitrarily long. This could happen if the code being run in another thread never releases the v8 lock and runs in a loop which v8 cannot interrupt (e.g. the loop never calls back into v8).

It is illegal for the unlock option to be enabled if ANY of the following applies:

  * The callback itself will "use" v8. If it uses a `v8::Locker` to fence its access then it _is_ legal to use v8 in that function even if unlocking is enabled at this API's level.
  * Any of the return- or argument types, or the containing type itself for bound class methods, are  "blacklisted", meaning that `IsUnlockable<T>::Value` is false (that includes the common v8 types, e.g. `v8::Handle<Anything>` or `v8::Arguments`). These types cause unlocking to be disabled by default and a compile-time assertion is triggered if one explicitly tries to enable unlocking for such a function. By extension, but more concretely...
  * `InvocationCallback`-like functions will, if unlocking is enabled, trigger a compile-time assertion. We _cannot_ unlock for these because that would make using the `v8::Arguments` object illegal (which would mean that we could not legally convert and pass on the arguments to the native function!).

There might be other corner cases where unlocking v8 is semantically illegal at this level of the API but are not caught as compile-time errors. The "out of the box" behaviour uses template magic to disable unlocking by default for all known-illegal signatures. See the `IsUnlockable<>` API docs for how to add additional types to "the blacklist" (it requires only a new template specialization with one enum/boolean value).

i have in fact seen binding cases where the default determination of "can we safely unlock v8?" is incorrect, leading to v8 assertions (app crashes) at runtime. In such cases v8's assertion dump showed me where the problem was (which function calls) and i could use that info to disable unlocking for those few functions. They caused this error because they outwardly (in their signatures) use only non-v8 types, but internally they use v8 without also using a `v8::Locker` (they assume it's being called from JS and therefore already locked). So they crashed. In such cases, unlocking should be explicitly disabled for that bind, as shown above. If you are binding a class and want to disable unlocking for _all_ bound member functions of that class, do:

{{{
template <>
cv::IsUnlockable<MyType> : cv::tmp::BoolVal<false> {};
}}}

That effectively adds `MyType` to the "do not unlock" blacklist, and any bound JS functions which are members of that type, return that type, or have it in their arguments list will have unlocking support disabled by default (this is a compile-time decision). In such cases, explicitly enabling locking for any such function will cause a compile-time assertion to be triggered, just as it does for functions having v8 data types in their signatures. For example, assuming the above "blacklist specialization" is in place:

{{{
v8::InvocationCallback cb;

cb = cv::FunctionToInCa< int (MyType *, double), some_function >::Call;
// That's legal b/c unlocking defaults to false.
// But this will fail to compile:
cb = cv::FunctionToInCa< int (MyType *, double), some_function, true >::Call;
// because unlocking _cannot_ be legally enabled for that function (because of
// the IsUnlockable<MyType> specialization).
}}}

Note, however, that _non-member functions_ bound as JS-side member functions to such a native do not "know" that they have been "upgraded" to be a member method, and do not consider the bound type for unlocking purpose (but parameter/return types are considered). In such a case, explicitly disabling locking for that function might be required (see above).

==Special Case: Catching native Exceptions==

v8 does not like for client-thrown exceptions to propagate through it, and therefore code like the following can be dangerous to an app's lifetime:

{{{
v8::InvocationCallback cb = cv::FunctionToInCa< int (),someFuncWhichThrows>::Call;
}}}

If that function throws in the context of a JS-initiated call, it might crash v8. The internal function binding mechanisms catch `(std::exception const &)` and convert it to a v8 exception. They catch all other exceptions and convert them to an "unknown error" in JS. However, that behaviour is largely for historical reasons and may be removed in favour of what follows...

The `InCaCatcher` class template creates an `InvocationCallback` function which calls a client-specified callback function and catches any exceptions of a given type. It has a template option which specifies whether other exceptions should be propagated or converted into "unknown error" for JS, and this property allows us to chain the catchers to handle multiple concrete exception types.

It can, in principal, catch and report any exception type which meets the following conditions: it must have a const member method taking no arguments and returning an error message value in a type which is convertible to JS using `CastToJS()`. e.g. `char const * std::exception::what()` qualifies nicely. A hypothetical (`int MyException::GetErrorCode()`) would also qualify, provided it is const. (The const limitation is unfortunate - my template-fu isn't quite good enough, i guess.)

`InCaCatcher` has a relatively detailed interface, which is documented (in corresponding detail) here:

  [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/detail/invocable_core.hpp invocable_core.hpp]

Search that file for `struct InCaCatcher` and the API docs are just above that.

The `InCaCatcher_std` template is a `InCaCatcher` convenience wrapper which handles `std::exception` errors.

Example usage:

{{{
typedef InCaCatcher<
       std::exception, // type to catch
       char const *(), // signature of message-getter
       &std::exception::what, // message-fetching method
       MyCallbackWhichThrows, // the InvocationCallback to try/catch
       false // whether to propagate other exceptions or not (default=false)
   > Catcher;

// Or, more simply (for std::exception):
typedef InCaCatcher_std< MyCallbackWhichThrows > Catcher;

// Get the callback function with:
v8::InvocationCallback cb = Catcher::Call;
}}}

For examples of chaining these to support multiple exception types, see the API documentation.

==Forwarding v8-supplied Function Arguments to non-bound Functions==

  * `forwardFunction()`
  * `forwardMethod()`
  * `forwardConstMethod()`

Those functions allow the client to pass on `v8::Arguments` to non-bound functions "manually".

*Achtung:* Because these functions use `FunctionToInCa`, they inherit the "v8 unlocking" behaviour from that class. That is described in much more detail in another section of this page, but in short: if the arguments list or return value of the function does not have any v8 types (`v8::Handle`, `v8::Arguments`, etc.) then then the v8 engine is _unlocked_ for the duration of the native call. _If_ the function, despite having no v8-specific arguments/return type, internally uses v8 (or calls another function which does), then it _must_ also use a `v8::Locker` _or_ clients must use `FunctionToInCa` (or compatible) instead of these functions and explicitly disable locking (see the documentation and examples elsewhere on this page). If one of these two conditions are _not_ met, v8 will trigger an assertion at runtime (when the function is called from JS), killing the application (and frustrating the user). Debug builds of libv8 will dump an explanation of the error to `stderr`, but non-debug builds will silently crash.

=But wait, there's more!=

The code includes the following additional utilities:

  * [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/properties.hpp properties.hpp] - templates for binding native global or member variables to JS objects. These basically work like `FunctionToInCa` and friends, but create `v8::AccessorSetter()` and `v8::AccessorGetter()` implementations using templates to bind JS properties directly to native variables or to methods/functions which proxy all get/set access on the JS property.
  * [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/arguments.hpp arguments.hpp] - templates for "interrogating" v8-provided arguments, for use in making templates/functors which can dispatch to various native bindings based on near-arbitrary argument state (count, type, etc.).
  * [V8Convert_ClassCreator] - yet another C++-to-JS class binding mechanism. Based on v8-juice's [ClassWrap], with the same overall design but a slightly different policy set.
  * [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/V8Shell.hpp V8Shell.hpp] provides a really simple way to get v8 integrated quickly into an application. Just create one object, optionally extend the JS environment with your functionality, and start running JS code through it. See [http://code.google.com/p/v8-juice/source/browse/convert/addons/shell-skel/shell.cpp shell.cpp] for a sample application. See: [V8Convert_Shell].

==Easily Binding C++ Classes==

See [V8Convert_ClassCreator].

== Binding Native Variables/Properties to JS ==

Some examples of binding native properties to JS:

{{{
// namespace- or global scope:
std::string sharedString;
std::string getSharedString()
    { return sharedString; }
void setSharedString(std::string const & s) 
    { sharedString = s; }

...

// Convenience typedef:
typedef v8::convert::PropertyBinder PB;


// Assume: 'proto' is our ObjectTemplate prototype.

// Bind non-member variable directly to a JS property:
PB::BindSharedVar<std::string, &sharedString>
                 ("sharedString", proto );

// BindSharedVarRO() binds it read-only.

// Or bind it read-only via a getter function:
PB::BindGetterFunction<std::string (),
                      getSharedString>
                      ("sharedString", proto);

// Or bind it via getter/setter functions:
PB::BindGetterSetterFunctions<std::string (),
                              getSharedString,
                              void (std::string const &),
                              setSharedString>
                              ("sharedString", proto);
}}}

(Pedantic note: v8 apparently does not allow us to bind a setter without also binding a getter. My attempts to do so caused crashes.)

JS properties can be bound to native _member_ properties similarly using the `MemberPropertyBinder` subclass of `PropertyBinder`. Note that for member binding to work, the JS class being bound must "wrap" that native class. i.e. that only works with "fully wrapped" classes (e.g. see [V8Convert_ClassCreator]).

The property-binding API has a much richer feature set than is demonstrated here, by the way.

==Passing v8 Arguments directly to Constructors==

The `CtorForwarder` class assists in forwarding `v8::Arguments` objects to constructors. Usage examples:

{{{
// Typedefs for 3 different ctors:
typedef cv::CtorForwarder<MyType * ()> Ctor0;
typedef cv::CtorForwarder<MyType * (int)> Ctor1;
typedef cv::CtorForwarder<MyType * (argType1,argType2)> Ctor2;

// We can call these individually:
MyType * my = Ctor0::Call( argsObject );

// Or we can group them together and dispatch based on the number of arguments pass in:
typedef cv::CtorForwarderDispatcher<
    cv::tmp::TypeList<
        Ctor0, Ctor1, Ctor2
    > > Dispatch;
MyType * my = Dispatch::Call( argsObject );
}}}

Unlike with most other bindings, the argument types do not need to match _exactly_. The types declared in the `CtorForwarder` instantiation will be used for purposes of converting the arguments from JS to native values. As long as those types can be implicitly converted to the types accepted by the constructor(s) then it should work okay. e.g. you can declare the forwarder as having an `int` argument even though the ctor really takes a `double`. (However, that would cause any doubles passed in from JS space to first be converted to an integer, which would lose precision.)

An additional property of this particular binding is that we can bind to constructors which have default values for some arguments. e.g. if a constructor has 2 required arguments and 2 more optional ones, we can bind it as a 2, 3, and/or 4-arg constructor.

=Brief Overview of `v8::convert` Architecture=

This API is made up of several distinct components, each one layered on top of the next:

  * Basic template-metaprogramming-related types, like a `TypeList` template and various utilities for querying them. Most of these are not really considered to be part of the public interface, but are necessary implementation details. Occasionally one of them leaks through to client-side code, most notably `TypeList`, which is used by some templates to implement overloading.
  * The core type conversions layer, e.g. `CastToJS()`/`CastFromJS()`.
  * Function/Method-signature-related templates. These do not do any JS/C++ conversions, but provide a mechanism with which we can store complete type information for a given function signature. These bits form the basis of the function binding API, but are not specific to that API.
  * The function-to-`v8::InvocationCallback` conversions. This provides tons of template glue which creates `v8::InvocationCallback` functions by converting near-arbitrary function signatures to `v8::InvocationCallback`. These would not be possible without `CastToJS()` and `CastFromJS()`, which are used to convert all arguments and return types from/to JS.

One of the most significant properties of this API is that it can report a wide variety of conversion errors at compile-time. Conversion APIs which are based on macros, as opposed to templates, (depressingly common in real-world v8 extension libraries) cannot come _anywhere close_ to achieving the flexibility and type-safety of this library.

For example, the following errors will show up at compile time, not runtime:

{{{
int my_function( int, double );

v8::InvocationCallback cb;

// This is OK:
cb = cv::FunctionToInCa< int (int,double), my_function>::Call; 

// Compile error: type mismatch:
cb = cv::FunctionToInCa< int (int,int), my_function>::Call;

// Compile error: parameter count mismatch:
cb = cv::FunctionToInCa< int (double), my_function>::Call;
}}}

As a side-note: that's not to say macros are absolutely evil - combining macros with this API can often greatly reduce the amount of typing needed to create bindings. For example, i often do the following in client-side code:

{{{
#define M2I cv::MethodToInCa
#define C2I cv::ConstMethodToInCa
#define F2I cv::FunctionToInCa
#define CATCHER cv::InCaCatcher_std
}}}

But since the advent of `ToInCa` (7 hours ago, as of this writing ;), i've pretty much stopped doing even that.

=Code Demos and Sample Bindings=

The [http://code.google.com/p/v8-juice/source/browse/#svn/convert/addons addons  directory] of the `v8::convert` source tree includes some sample v8 bindings created using this API. The code includes:

  * The `ConvertDemo.?pp` and `test.js` files in this source tree's root directory give a very thorough demonstration, showing off just about every feature the library offers.
  * A [V8Convert_ByteArray ByteArray class] for handling binary data in JS space.
  * A [JSPDO database access abstraction API].
  * A basic [V8Convert_Socket socket API].

Each of the "addons" includes a basic v8 shell app which includes the JS bindings provided by that addon, making it simple to try out the code before including it into one's own project (on many Unix-like platforms, at least).