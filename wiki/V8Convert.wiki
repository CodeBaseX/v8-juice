#summary The v8::convert sub-project
#labels Phase-UserDocs,Topic-CPlusPlus,Featured

<wiki:toc max_depth=4></wiki:toc>

= v8::convert =

Source code: [http://code.google.com/p/v8-juice/source/browse/#svn/convert] (see [http://code.google.com/p/v8-juice/source/checkout this link] for checkout instructions.)

The `v8::convert` API is a spin-off of the core-most components of the v8-juice library. It has a templates-heavy, header-only implementation and has no 3rd-party dependencies beyond the STL and whatever v8 needs. It provides the following features:

  * Converting between v8 Value handles and "native types" using a generic interface. This allows us to write generic algorithms which convert between JS/C++ without having to know the exact types we're dealing with.  The basic POD types and some STL types are supported out of the box and plugging in one's own types is normally quite simple.
  * Converting free- and member functions into `v8::InvocationCallback` functions. These generated functions convert the !JavaScript-originated function arguments into native counterparts, forward the data to the original native function, and convert the return values back to something JS can use. (The `void` return type is translated to the `undefined` JS value.)
  * Binding JS object properties to native shared or member properties or accessor/mutator functions/methods.

The first two core features give us all we need in order to be able to bind near-arbitrary C/C++ functions with !JavaScript, insofar as cross-language calling conventions and type conversions allow us to do so. The last feature is really just "sugar" (but also quite convenient at times).

While these features are easily summed up in a short list, their broader implications are quite large. The ability to convert functions from one signature to another (at compile time, by the way) has proven to be deceptively powerful, allowing users to bind new functions to v8 with unprecedented ease. We can combine this with template meta-programming techniques to do weird things like combine multiple native functions into a single `InvocationCallback` function which dispatches to the proper native function based on the number of arguments (see the examples of argument overload later on down this page).

For cases where the "automatic" function-to-!InvocationCallback conversions are not possible or not suitable, the type-conversion API can still simplify the implementation of custom `v8::InvocationCallback` functions.

All of the conversions are compile-time typesafe where possible and fail gracefully (e.g. using a JS-side exception as opposed to an immediate crash) when such a determination can only be made at runtime.

This code originated as the core-most component of the [http://code.google.com/p/v8-juice v8-juice library]. After a couple years i felt compelled to refactor it into a toolkit usable by arbitrary v8-using clients, doing a bit of cleanup along the way. The eventual intention is that this code will replace the v8::juice::convert code.

The most important functions and types, from a user's perspective, are listed below. Most of the code in this library are internal template specializations which take care of the dirty work. Typical clients won't normally need more than what's described on this page.

A very special thanks goes to James Pike, author of [https://github.com/tsa/vu8 vu8], for his helpful tips on getting function-pointer-style template arguments working. These allow for more readable templates when compared to the v8-juice API.

=Converting Types=

  * `CastToJS<T>()`: converts the given object to a `v8::Handle<v8::Value>`.
  * `CastFromJS<T>()`: converts a v8 value to a `T` (or `T*` for most non-POD types).

These are very thin wrappers around `NativeToJS<>` and `JSToNative<>`, and work identically to the v8-juice APIs with the same names (see [ConvertingTypes]). A few special-case overloads also exist to avoid call ambiguities in some cases or to cover special cases (most notably those taking (`char *`) and `v8::InvocationCallback` arguments).

Here's a silly trick you can do with `CastToJS()`:

{{{
v8::Handle<v8::Value>
myInvocationCallback( v8::Arguments const & ) {
    try {
     ....
    }
    catch( std::exception const & ex ) {
       return cv::CastToJS(ex); // triggers a JS-side exception
    }
}
}}}


=Implementing Custom Conversions=

  * `JSToNative<T>`: template to convert JS values to `T` (_almost_ always `T*` for non-POD types).
  * `NativeToJS<T>`: template to convert `T` objects to JS counterparts. Adding this support for client-side types requires adding tooling which maps the native object to a JS instance (or that the bound type hold this information itself).

These work identically to the v8-juice APIs with the same names (see [ConvertingTypes]), the only client-visible difference being that the classes (and thus client-defined specializations) are defined in a different namespace than in v8-juice. Future (post-2010) development in the type conversions API will happen in this copy instead of the `v8::juice` copy.


=Converting Functions to `v8::InvocationCallback`=

  * `FunctionToInvocationCallback()`
  * `MethodToInvocationCallback()`
  * `ConstMethodToInvocationCallback()`

By using only those 3 function templates (all with identical interfaces) clients can bind
a wide variety of native functions to arbitrary JS objects (where language calling conventions and cross-language type conversions allow).

Each of those function has a corresponding class with a similar name. The class provides a "fully typed" conversion of the function and remembers the function's arity (how many arguments it takes):

  * `FunctionToInCa<>`
  * `MethodToInCa<>`
  * `ConstMethodToInCa<>`

In all three cases, the static `Call()` method of those classes is the function used by the function converters shown above. An example should clarify that point:

{{{
v8::InvocationCallback cb1 = FunctionToInvocationCallback<int (char const *),::puts>;
v8::InvocationCallback cb2 = FunctionToInCa<int (char const *),::puts>::Call;
}}}

Those both refer to the same underlying function (though their memory addresses differ). The second form is actually a tad bit more efficient because the first approach creates another one-line wrapper function between v8 and the bound function. The first form is, however, more prevalently documented because the client-side value of the second form was not recognized as early on as it should have been.

Note that binding to non-static member member methods requires (at runtime), that `CastFromJS<T>()` can convert the current JS 'this' object to its native counterpart. See the included demo code for how to set this up (we just have to create a `JSToNative<>` specialization).

Support for const- and non-const methods are split into two implementations because some compilers reportedly cannot properly choose differing specializations when the difference is only in constness. (i have only heard of this being a problem on MSVC.)

Because these templates _create_ `v8::InvocationCallback` functions at compile-time, they require no dynamically-allocated proxy objects or other hidden memory usage like some binding mechanisms require. The only overhead these templates add is the conversion of arguments/return values to/from JS. The library does as much work as possible at compile time to help detect type-conversion errors early and help avoid extra runtime costs.


== Examples ==
Some examples of binding functions and methods:

{{{
#include <cstdio> // puts()
...
namespace cv = v8::convert;

v8::InvocationCallback cb; // v8's generic callback function interface

// Here's how we can "convert" various native functions to
// v8::InvocationCallback functions:

// Function: int puts(char const *)
cb = cv::FunctionToInvocationCallback<
       int (char const *), ::puts
     >;

// Class method: double MyType::multiply(double, double)
cb = cv::MethodToInvocationCallback<
       MyType,
       double (double,double),
       &MyType::multiply
     >;

// Const class method:
//    char const * MyType::errorCodeToString(int) const
cb = cv::ConstMethodToInvocationCallback<
       MyType,
       char const * (int),
       &MyType::errorCodeToString
     >;

// Here's how we can bind a JS-side garbage-collection-triggering
// function:
cb = cv::FunctionToInvocationCallback<bool (),v8::V8::IdleNotification>;
}}}

Those examples demonstrate _all_ of the public API needed for converting functions to `v8::InvocationCallback` equivalents! There are some additional templates which add features on top of those, but those are all one really needs for most basic function bindings.

It might be interesting to note that the above functions are _created_, but _not actually called_, by the above code (note that we pass no non-template parameters to them).

== Caveats and Unsupported Functions ==

Some examples of function signatures which _cannot_ (or must not) be converted using this framework:

  * `int func( someType ** )`: pointer-to-pointer cannot be translated generically to JS
  * `int func( void * )`: Giving access to `void *` in JS makes it really easy to crash your apps from script code.
  * `int func(...)`: elipsis lists, `va_list`, and C++0x var-args are not directly supported.
  * !JavaScript has no inherent support for binary data, and v8's string class does not support it. Thus this API must not be used with functions returning binary data (e.g. via `char [const]*`).

Supported, but ill-advised:

  * `anything * func(anything)`: if the function returns dynamically-allocated memory, or transfers ownership of the returned memory to the caller, it _will_ cause a leak unless that memory has been somehow given over to v8 from within that function. That said... when using a class-binding mechanism which creates the native object from JS code and has enough internal plumbing to support an implementation of `NativeToJS<MyType>`, we can in fact make this conversion legal for many client-defined types.

== The (`char [const] *`) Problem ==

Because of issues regarding the ownership and lifetimes of raw C-style string, functions taking `(char const *)` have a few relatively minor limitations:

  * The C-strings _must_ be `NULL` or nul-terminated. It cannot be used with binary data because they are converted to JS strings.
  * Non-const (`char *`) is not supported. We could partially implement it using a proxy, but the changes would get lost on their way back to JS space because the JS calling conventions do not allow us to pass changes to strings back this way.
  * The bound function _must not_ hold the pointer it is passed after it returns. It must either consume or ignore the input, and keep no copy of the pointer itself.
  * The internal conversion process uses `v8::String::Utf8Value`, and "should" be safe for use with functions accepting ASCII or UTF8 input. Behaviour with any other encodings is undefined.
  * If passed a JS `null` or `undefined`, it converts to a literal `NULL`, otherwise it will convert to a string (though possibly empty). This is significant for functions which treat `NULL` different than an empty string (like `strlen()`, which may crash your app if passed `NULL`).

When native functions return (`char const *`), they are converted to v8 Strings, and therefore have the same encoding limitations as for C-string function arguments. A return value of `NULL` is converted to a JS `null`, as opposed to an empty string.


This support allows us to convert functions like the following to `v8::InvocableCallback`s:

{{{
char const * cstring_test( char const * c )
{
    std::cerr << "cstring_test( @"<<(void const *)c
              <<") ["<<(c ? c : "<NULL>")<<"]\n";
    return c;
}

v8::InvocationCallback cb =
   cv::FunctionToInvocationCallback<
     char const * (char const *),
     cstring_test
    >;
}}}

If we bind that to JS with the name `cstr`:

{{{
var jstr = "Hi, world!";
jstr = cstr(jstr); print(jstr);
jstr = cstr(undefined); print(jstr);
jstr = cstr(null); print(jstr);
jstr = cstr("Bye, world!"); print(jstr);
}}}

The output looks something like:

{{{
cstring_test( @0x984acbc) [Hi, world!]
Hi, world!
cstring_test( @0) [<NULL>]
null
cstring_test( @0) [<NULL>]
null
cstring_test( @0x984acbc) [Bye, world!]
Bye, world!
}}}

(The fact that the pointer addresses are the same in the first and last calls is a mere fluke of memory re-allocation, and must not be understood to mean that the address is somehow stable across calls.)

==Special Case: `v8::InvocationCallback`-like Functions==

The library provides special support for binding functions which "look like" a `v8::InvocationCallback`. The definition of "looks like" is: the function takes only a single `(v8::Arguments const &)` argument and returns any type.

Such functions are treated like `v8::InvocationCallback` instances, in that they can accept any number of arguments of any type. The return value is converted to a `v8::Handle<v8::Value>` (or to JS `undefined` for `void` returns).

Examples of what we consider to be `v8::InvocationCallback`-like:

{{{
int my_callback( v8::Arguments const & );
void MyType::callback( v8::Arguments const & );
double MyType::constCallback( v8::Arguments const & ) const;
}}}

And we can create `v8::InvocationCallback` functions from them like:

{{{
InvocationCallback cb;

cb = FunctionToInvocationCallback< int (Arguments const &),
                                my_callback >;

cb = MethodToInvocationCallback< MyType,
                               void (Arguments const &),
                               &MyType::callback >;

cb = ConstMethodToInvocationCallback< MyType,
                               double (Arguments const &),
                               &MyType::constCallback >;
}}}

(Pretty simple, huh?)

Free functions bound this way have a particularly interesting property: if such a function is bound as a member of a `T` native object, we can access the native `this` pointer from inside that function like this:

{{{
int my_callback( v8::Arguments const & argv )
{
   T * self = cv::CastFromJS<T>(argv.This());
   if( !self ) {
       // no native T found. This might or might not
       // be an error, depending on app-specific conditions.
   }
   ...
}
}}}


==Special Case: Overloading based on Arity==

The API has basic support for overloading multiple `InvocationCallback`s based on their arity (the number of arguments they require). Two approaches are shown here, but i highly recommend the second one except for very simple cases (only two overloads).

===Approach 1: `InCaOverloader`===

The first approach is a bit verbose, but it works, and it looks something like this:

{{{
// The funcs we want to overload:
int myfunc1(int); // 1 arg
int myfunc2(int, int); // 2 args
int myfuncN( v8::Arguments const & ); // fallback handler (optional)

// Set up a couple typedefs so that the following code is more readable:
typedef cv::InCa< cv::FunctionToInvocationCallback<int (int), myfunc1> > my1;
typedef cv::InCa< cv::FunctionToInvocationCallback<int (int,int), myfunc2> > my2;
typedef cv::InCa< cv::FunctionToInvocationCallback<int (v8::Arguments const &), myfuncN> > myN;

// More readability typedefs...

// Proxy for N arguments:
typedef cv::InCaOverloader< -1, // arity
                            myN::Call // callback when arity matches
                           > OloadN;

// Proxy for 2 or N:
typedef cv::InCaOverloader< 2, // arity
                            my2::Call, // callback when airty matches
                            OloadN::Call // callback when arity does NOT match
                           > Oload2;

// Proxy for 1 or 2 or N arugments:
typedef cv::InCaOverloader< 1, my1::Call, Oload2::Call > OloadAll;


// Now we have an InvocationCallback proxy which will dispatch based
// on the number of arguments:
InvocationCallback cb = OloadAll::Call

// cb is now a function which basically says:
// If passed 1 arg, call myfunc1(), else... If passed 2 args, call
// myfunc2(), else... if passed anything else (including no args),
// call myfuncN().
}}}

`InCaOverloader` can be chained this way (with increasing code uglification!) to support an arbitrary number of varying arities. The 3rd (optional) parameter is the callback to call if the arity of the call (at runtime) does not match the number given to the template. The default fallback callback throws a JS-side exception warning about the argument count mismatch.

If an overloaded function needs to be able to take any number of arguments, it must itself be "!InvocationCallback-like" and the `InCaOverloader` must be given an arity value of `-1`. In addition, that entry should be the _last_ one in the `InCaOverloader` chain (because of how the arity value check works).

===Approach 2: `InCaOverloadList`===

The second approach is significantly less verbose and more readable than `InCaOverloader`, and it auto "automatically" determines the overload arities. It uses a "type list" to construct the list of overloads:

{{{
// Overload 4 variants of a member function:
typedef cv::InCaOverloadList< cv::tmp::TypeList<
        cv::MethodToInCa<T, void(), &T::overload0>,
        cv::MethodToInCa<T, void(int), &T::overload1>,
        cv::MethodToInCa<T, void(int,int), &BoundNative::overload2>,
        cv::MethodToInCa<T, void(v8::Arguments const &), &T::overloadN>
    > > MyOverloads;

// Get the InvocationCallback proxy which does the arity-based dispatching:
v8::InvocationCallback cb = MyOverloads::Call;
}}}

Note that only one line of that code is evaluated at runtime - the rest is all done at compile-time. The above generates a whole family of `v8::InvocationCallback` functions (at least (overload count + 1) of them, though there are a couple others hidden behind the scenes) and combines them into a single `v8::InvocationCallback` dispatcher function, `MyOverloads::Call()`.

There is actually a limit to how many overloads you can provide in a single `InCaOverloadList`, but the lower limit is _at least_ 10 (and the library can be built to support many more than that). (If you're overloading 10+ variants of one function then the design probably needs to be reconsidered!)

==Special Case: Unlocking the v8 Engine==

Consider this function binding:

{{{
#include <unistd.h> // sleep(), or Sleep(N*1000) on Windows
v8::InvocationCallback cb =
    cv::FunctionToInvocationCallback<
       unsigned int (unsigned int), sleep
     >;
}}}

When that callback is called, the calling code is locking v8, meaning that other v8-using threads cannot preempt it. When calling C-level APIs which themselves do not call back into v8, we normally instead want to tell v8 that other threads may run. That is done like this:

{{{
... somewhere inside a v8 callback function ...
{
  v8::Unlocker unlock;
  nativeFunction(...);
}
... v8 is locked again here, so we can use v8 again ...
}}}

This library currently doesn't have a generic mechanism for adding this support via the provided templates. i have some ideas on how it might be done, but nothing has materialized yet.

==Special Case: Catching native Exceptions==

v8 does not like for client-thrown exceptions to propagate through it, and therefore code like the following can be dangerous to an app's lifetime:

{{{
v8::InvocationCallback cb = cv::FunctionToInCa< int (),someFuncWhichThrows>::Call;
}}}

If that function throws in the context of a JS-initiated call, it might crash v8. The internal function binding mechanisms catch `(std::exception const &)` and convert it to a v8 exception. They catch all other exceptions and convert them to an "unknown error" in JS. However, that behaviour is largely for historical reasons and may be removed in favour of what follows...

The `InCaCatcher` class template creates an `InvocationCallback` function which calls a client-specified callback function and catches any exceptions of a given type. It has a template option which specifies whether other exceptions should be propagated or converted into "unknown error" for JS, and this property allows us to chain the catchers to handle multiple concrete exception types.

It can, in principal, catch and report any exception type which meets the following conditions: it must have a const member method taking no arguments and returning an error message value in a type which is convertible to JS using `CastToJS()`. e.g. `char const * std::exception::what()` qualifies nicely. A hypothetical (`int MyException::GetErrorCode()`) would also qualify, provided it is const. (The const limitation is unfortunate - my template-fu isn't quite good enough, i guess.)

`InCaCatcher` has a relatively detailed interface, which is documented (in corresponding detail) here:

  [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/detail/invocable_core.hpp invocable_core.hpp]

Search that file for `struct InCaCatcher` and the API docs are just above that.

The `InCaCatcher_std` template is a `InCaCatcher` convenience wrapper which handles `std::exception` errors.

Example usage:

{{{
typedef InCaCatcher<
       std::exception, // type to catch
       char const *(), // signature of message-getter
       &std::exception::what, // message-fetching method
       MyCallbackWhichThrows, // the InvocationCallback to try/catch
       false // whether to propagate other exceptions or not (default=false)
   > Catcher;

// Or, more simply (for std::exception):
typedef InCaCatcher_std< MyCallbackWhichThrows > Catcher;

// Get the callback function with:
v8::InvocationCallback cb = Catcher::Call;
}}}

For examples of chaining these to support multiple exception types, see the API documentation.

=Forwarding v8-supplied Function Arguments to non-bound Functions=

  * `forwardFunction()`
  * `forwardMethod()`
  * `forwardConstMethod()`

Those functions allow the client to pass on `v8::Arguments` to non-bound functions "manually".

_Achtung:_ these _must not_ be used to implement "unlocked" operations (as shown above) because the conversions themselves _must_ "use" v8, and doing them while v8 is unlocked results in undefined behaviour. (To "use" v8 means to do anything with its API, including dereferencing value handles, which the conversions must do in order to convert them for passing on the calls.)

=But wait, there's more!=

The code includes the following additional utilities:

  * [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/properties.hpp properties.hpp] - templates for binding native global or member variables to JS objects. These basically work like `FunctionToInvocationCallback()` and friends, but create `v8::AccessorSetter()` and `v8::AccessorGetter()` implementations using templates to bind JS properties directly to native variables or to functions which proxy all get/set access on the JS property.
  * [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/ClassCreator.hpp ClassCreator.hpp] - yet another C++-to-JS class binding mechanism. Based on v8-juice's [ClassWrap], but not _quite_ as configurable.
  * [http://code.google.com/p/v8-juice/source/browse/convert/include/v8/convert/V8Shell.hpp V8Shell.hpp] provides a really simple way to get v8 integrated quickly into an application. Just create one object, optionally extend the JS environment with your functionality, and start running JS code through it. See [http://code.google.com/p/v8-juice/source/browse/convert/addons/shell-skel/shell.cpp shell.cpp] for sample application. 

== Binding Native Variables/Properties to JS ==

Some examples of binding native properties to JS:

{{{
// namespace- or global scope:
std::string sharedString;
std::string getSharedString()
    { return sharedString; }
void setSharedString(std::string const & s) 
    { sharedString = s; }

...

// Convenience typedef:
typedef v8::convert::PropertyBinder PB;


// Assume: 'proto' is our ObjectTemplate prototype.

// Bind non-member variable directly to a JS property:
PB::BindSharedVar<std::string, &sharedString>
                 ("sharedString", proto );

// BindSharedVarRO() binds it read-only.

// Or bind it read-only via a getter function:
PB::BindGetterFunction<std::string (),
                      getSharedString>
                      ("sharedString", proto);

// Or bind it via getter/setter functions:
PB::BindGetterSetterFunctions<std::string (),
                              getSharedString,
                              void (std::string const &),
                              setSharedString>
                              ("sharedString", proto);
}}}

(Pedantic note: v8 apparently does not allow us to bind a setter without also binding a getter. My attempts to do so caused crashes.)

JS properties can be bound to native _member_ properties similarly using the `MemberPropertyBinder` subclass of `PropertyBinder`. Note that for member binding to work, the JS class being bound must "wrap" that native class. i.e. that only works with "fully wrapped" classes.

==Passing v8 Arguments directly to Constructors==

The `CtorForwarder` class assists in forwarding `v8::Arguments` objects to constructors. Usage examples:

{{{
// Typedefs for 3 different ctors:
typedef cv::CtorForwarder<MyType * ()> Ctor0;
typedef cv::CtorForwarder<MyType * (int)> Ctor1;
typedef cv::CtorForwarder<MyType * (argType1,argType2)> Ctor2;

// We can call these individually:
MyType * my = Ctor0::Ctor( argsObject );

// Or we can group them together and dispatch based on the number of arguments pass in:
typedef cv::CtorForwarderDispatcher<
    cv::tmp::TypeList<
        Ctor0, Ctor1, Ctor2
    > > Dispatch;
MyType * my = Dispatch::Ctor( argsObject );
}}}

Unlike with most other bindings, the argument types do not need to match _exactly_. The types declared in the `CtorForwarder` instantiation will be used for purposes of converting the arguments from JS to native values. As long as those types can be implicitly converted to the types accepted by the constructor(s) then it should work okay. e.g. you can declare the forwarder as having an `int` argument even though the ctor really takes a `double`. (However, that would cause any doubles passed in from JS space to first be converted to an integer, which would lose precision.)

=Code Demos and Sample Bindings=

The [http://code.google.com/p/v8-juice/source/browse/#svn/convert/addons addons  directory] of the `v8::convert` source tree includes some sample v8 bindings created using this API. The code includes:

  * The `ConvertDemo.?pp` and `test.js` files in this source tree's root directory give a very thorough demonstration, showing off just about every feature the library offers.
  * A [V8Convert_ByteArray ByteArray class] for handling binary data in JS space.
  * A [JSPDO database access abstraction API].
  * A basic [V8Convert_Socket socket API].

Each of the "addons" includes a basic v8 shell app which includes the JS bindings provided by that addon, making it simple to try out the code before including it into one's own project (on many Unix-like platforms, at least).