#summary V8Convert's basic shell class
#labels Phase-UserDocs,Topic-JS-API
<wiki:toc/>

One of the minorly problematic things in integrating v8 into an application is the setup needed to get v8 initialized. We've got to create a context, a global object template, and a global object. We have to set up those object object and possibly make sure that we have the proper locking in place (this is app-specific and the documentation on the topic is sparse).

The `V8Shell` class tries to fill that gap, making it a snap to get a v8 environment initialized. To demonstrate, the following simple program accepts a JS script filename on the command line and runs it:

{{{
#include "v8/convert/V8Shell.hpp"
#include <cassert>

int main(int argc, char const * const * argv) {
    assert( argc >= 2 ); // obviously, user-friendly programs don't do this!
    namespace cv = v8::convert;
    cv::Shell shell(NULL, argc, argv);
    shell.SetupDefaultBindings()
        ("gc", cv::FunctionToInCa<bool (),v8::V8::IdleNotification>::Call )
    ;
    // If we want to customize the environment (e.g. add more functions)
    // we should do it here.
    try {
        v8::TryCatch tryCatch;
        char const * fname = argv[1];
        v8::Handle<v8::Value> rc( shell.ExecuteFile( fname, &tryCatch ) );
        if( rc.IsEmpty() ) { // exception was reported by shell already
            return 2;
        }
    }
    catch(std::exception const & ex) {
        std::cerr << "Caught a std::exception: " << ex.what() << '\n';
        return 3;
    }
    catch(...) {
        std::cerr << "A non-std::exception native exception was thrown! Srsly.\n";
        return 4;
    }
    return 0;
}
}}}