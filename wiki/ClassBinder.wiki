#summary Overview of the ClassBinder class
#labels Topic-CPlusPlus,Phase-UserDocs

This is an extension of the [CreatingJSClasses page about creating JS classes]. Please read that page before reading this one. The page for the [ConvertingTypes v8::juice type conversions API] might also be helpful.

<wiki:toc max_depth='3'/>

=!ClassBinder=

!ClassBinder is a [CreatingJSClasses WeakJSClassCreator] subclass which makes use of
v8-juice's type conversions API to add features to the class binding process.
Unlike JSClassCreator and WeakJSClassCreator, !ClassBinder is not a
standalone implementation which can be used as-is in arbitrary v8 client
code - it requires [ConvertingTypes the v8-juice type conversions framework] in order to convert between native and JS types.

The source code and API documentation for this class is in 
[http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassBinder.h ClassBinder.h].

An interesting property of this class binding framework is that it's compile-time typesafe. Though v8 uses `void *` as the parameter type for destruction callbacks, the implementation uses a mix of class templates, private static functions, and an internal void-to-native mapping to ensure that only the correct types can, e.g., be passed to the correct destructor, and that `CastFromJS<TypeB>()` cannot cast (using the default conversions) to `TypeA`. The implementation is believed to be 100% typesafe.


=Binding member functions=

The primary feature added by !ClassBinder is the ability to bind native
member functions and variables of the wrapped type. The syntax for doing so is a tiny
bit odd, but there's a reason for it which we'll explain after we demonstrate:

{{{
int MyClass::func( double ); // function we want to wrap


ClassBinder<MyClass> bin;
binder.AddMemFunc< int /* return value type */,
		double /* first arg type*/,
		&MyClass::func /* member func */
	>( "myFunc" );
}}}

_WTF?_ Every function-wrapping framework i've seen so far passes
function pointers as function arguments to the function templates (got
that?). In this one, we pass the function pointer as a _template
parameter_ instead of as a function argument! Why? It's ugly, but
there are reasons for it.

First, it is compile-time typesafe and this allows us to set up the
callbacks such that it is impossible to mis-cast a (`void*`) pointer
to a (`T*`) (in fact, no casts are used at all for this, even though
v8 internally gives us only (`void*`) handles).

Secondly, it costs us nothing at runtime. If we passed
pointers to functions as the arguments, we would have to create a
small wrapper object for _each_ binding (that is, one per class/member
combination), and the wrapper's only purpose would be to forward the
call to a specific native object (which is found at runtime of
course).  We would have no logical place to store the call-wrappers
for later cleanup (long story) and we would effectively introduce a
memory leak for every bound function.

By using function pointers as template parameters, we bind the
function pointers at compile time and therefor need no intermediary
call-proxy object instance. We _still_ have plenty of internal proxy
functions, but they require no dynamic memory and are bound (and
possibly inlined) at compile-time.

The primary down-side to this approach, as opposed to passing function
pointers as _function_ arguments (not _template_ arguments), is that the
function pointer signature's contained types must exactly match the
types specified in the other template parameters. e.g. the following
will not work:

{{{
int MyClass::func( double );

...

binder.AddMemFunc< int, // return value type
		int /* first arg type. Must be of type double because: */,
		&MyClass::func /* int (MyClass::*)(double) */
		>
		("func");
}}}

That won't work because the template type for the first member function
argument is wrong - it must the type used by the signature of the given
member function (so in this case it must be `double` instead of `int`).

If i'm not mistaken, if we bound at runtime to function pointers (via an
internal functor used as a call wrapper), we could rely on implicity
type conversions to do this sort of type conversions for us. That would,
however, require the above-mentioned leak, which i'm not at all keen on.

The conversion of member function parameters to/from JS is achieved
using the `v8::juice::convert` API, and this code inherits most of the type
conversion limitations (and features) of that API. As an exception, it supports
member functions returning `void` (which the `v8::juice::convert` API cannot
directly handle).

=Binding member variables=

Again, the syntax is ugly, but not as ugly as that for binding functions. If we have a type with a `std::string` member named `str`, we can bind that member with:

{{{
binder.Set( "str",
     MemVarGetter<MY,std::string, &MY::str>,
     MemVarSetter<MY,std::string, &MY::str> );
}}}

Or, more succinctly:

{{{
binder.BindMemVar<std::string,&MY::str>( "str" );
}}}

which is basically a shorthand form of the above (but also uses different default access options for the generated function!).

The `MemVarSetter<>()` and `MemVarGetter<>()` templates create functions which set/get the native member using [ConvertingTypes CastFromJS() and CastToJS()]. This means that we can also bind members which are pointers to other wrapped types, and access those transparently via JS. e.g. if the MY type has a member `MY * other`, we can bind that:

{{{
binder.BindMemVar<MY *, &MY::other>( "other" );
}}}

Though whether or not such an automatic conversion makes sense for your case is another question entirely (e.g. it might be possible to leak objects or cause other problems if client code doesn't manage such pointers in a manner which is kosher in your API).

We can of course choose to apply only the getter or the setter if we like, to allow conversions in only one direction.

=Example of using !ClassBinder=

Here's an example of how `ClassBinder` can be used.

==A native type to bind==

First we need a native type. Oh, look, here's one:

{{{
struct my_native
{
    int func1() { return 42; }
    int func2(int x) { return x*2; }
    double func3(int x,int y) { return x*y; }
    std::string hi() { return "hi!"; }
    my_native * me() { return this; }
    bool him(my_native * him) { return true; }
    void avoid() {}
    void avoid1(int x ) {}
    void avoid2(int x,double d ) {}
    double takes3(int x, int y, int z) { return x * y * z; }
    std::string str;
    my_native * other;
    my_native() : str(),other(0)
    {}
};
}}}

Great, now that's out of the way...

==WeakJSClassCreatorOps specialization==

We need a `WeakJSClassCreatorOps<my_native>` specialization which defines the
common binding operations:

{{{
namespace v8 { namespace juice {
    template <>
    struct WeakJSClassCreatorOps<my_native>
    {
    public:
	enum { ExtraInternalFieldCount = 0 };
	typedef my_native WrappedType;
	static char const * ClassName() { return "MyNative"; }
	static WrappedType * Ctor( Arguments const & argv,
				   std::string & exceptionText)
	{
            return new my_native;
            // If we couldn't create from the given arguments
            // we would populate exceptionText with a description.
            // e.g. "Constructor requires two integer arguments!"
	}

	static void Dtor( WrappedType * obj )
	{
	    if( obj ) delete obj;
	}
    };
}} // namespaces
}}}

That example is feature-complete and ready for copy/paste into your source files.

==Set up automatic JS/C++ conversions==

The following "supermacro" hooks `my_native` in with the `v8::juice::convert`
API, so that we can use `CastToJS()` and `CastFromJS()` with
`my_native`. We want that in this because some of the `my_native`
members take or return pointers to `my_native` objects. Since the
function forwarding mechanism uses `CastToJS()` and `CastFromJS()` for
all type conversions, we want to be able to hook in to that so that `my_native`
objects can also be converted generically:

{{{
#define WEAK_CLASS_TYPE my_native
#include <v8/juice/WeakJSClassCreator-CastOps.h>
}}}

(That must be called from global-scope code!)

That will generate a pair of template specializations for the cast operators, and can be included multiple times in the same file (once per wrapped type).
See [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/WeakJSClassCreator-CastOps.h WeakJSClassCreator-CastOps.h] for the complete docs.

If the native type will never be passed as a parameter or returned
from a function (i.e. it will only be the `this` object) then these
conversions are not strictly required. They're easy to add and allow you pass the custom
types to/from other (non-member) functions with ease, so they're recommended.

For the extremely curious, that macro generates something like the following:

{{{
namespace v8 { namespace juice { namespace convert {
template <>
struct NativeToJS<my_native>
{
    Handle<Value> operator()( my_native * p ) const
    {
	Handle<Object> jo = ::v8::juice::WeakJSClassCreator<my_native>::GetJSObject(p);
	if( jo.IsEmpty() ) return Null();
	else return jo;
    }
};
template <>
struct JSToNative<my_native>
{
    typedef my_native * result_type;
    result_type operator()( Handle<Value> const & h ) const
    {
	return ::v8::juice::WeakJSClassCreator<my_native>::GetNative(h);
    }
};
} } } // namespaces
}}}

(See the [ConvertingTypes type conversions page] for the details.)

==Bringing it all together==

And now what we originally set out to to: bind `my_native` with JS:

{{{
    typedef ClassBinder<my_native> WT;
    WT w( v8::Context()->GetCurrent()->Global() );
    typedef my_native MY;
    w.Set("prop1", String::New("this is my first property"))
      .Set("answer", Integer::New('*'));
    w.BindMemFunc< int, &MY::func1>( "func1" )
     .BindMemFunc< int, int, &MY::func2 >( "func2" )
     .BindMemFunc< std::string,&MY::hi >( "hi" )
     .BindMemFunc< MY *,&MY::me >( "me" )
     .BindMemFunc< bool,MY *,&MY::him >( "him" )
     .BindMemFunc< double,int,int,&MY::func3 >( "func3" )
     .BindMemFunc< void,&MY::avoid >( "avoid" )
     .BindMemFunc< void,int,&MY::avoid1 >( "avoid1" )
     .BindMemFunc< void,int,double,&MY::avoid2 >( "avoid2" )
     .BindMemFunc< double,int,int,int,&MY::takes3 >( "takes3" )
     .BindMemVar< std::string, &MY::str >("str")
     .BindMemVar< MY *, &MY::other >("other")
    w.Seal();
}}}

Again, the templates syntax is ugly, but it also has no extra runtime memory costs other than that needed by the v8 internals and the conversion from JS to native.

While it isn't demonstrated here, `const` member functions can also be bound (the syntax is the same). For more information on binding member variables, see the API docs for `v8::juice::MemVarGetter<>()` and `v8::juice::MemVarSetter<>()` (in [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassBinder.h ClassBinder.h]).

==And finally... script code==

Once we've done all that, here's what it looks like in JS:

{{{
var m = new MyNative();
print('void returns:',m.avoid(),m.avoid1(32),m.avoid2(17,11));
print(m.hi());
print(m.func3(m.func1(),m.func2(m.func1())))
print(m.him(m));
print(m.me());
print(m.takes3(2,2,3));
print('m.str =',(m.str='bye, world!'));
print('m.other =',m.other);
m.other = new MyNative();
m.other.str = "i am the other!";
print('m.other.str =',m.other.str);
}}}

The output:

{{{
stephan@jareth:~/cvs/v8-juice/trunk/src/client/shell$ v8-juice-shell js/fwd.js
void returns: undefined undefined undefined
hi!
3528
true
[object Object]
12
m.str = bye, world!
m.other = null
m.other.str = i am the other!
}}}

=Dual JS/C++ Inheritance=

As of 20090324 WeakJSClassCreator supports dual JS/C++ inheritance. What does that mean?
It means that if we have native type called `ParentType` and a suclass called `SubType`,
and we bind both of them with WeakJSClassCreator, then the JS-side `SubType` objects can
access their _inherited_ bound member functions as if they were an object of type `ParentType`.
That sounds a bit confusing, but an example might clear it up:

{{{
class ParentType
{
  ...
  virtual int vfunc();
};
class SubType : public ParentType
{
...
};

... add WeakJSClassCreatorOps<ParentType>
    and WeakJSClassCreatorOps<SubType> ...

// And we can then do:
// Bind parent type:
typedef ClassBinder<ParentType> WP;
WP wp( targetObject );
wp.BindMemFunc< int, &ParentType::vfunc >("vfunc")
  .Seal();

// Bind subclass:
typedef ClassBinder<SubType> WS;
WS ws( targetObject );
ws.Inherit( wp )
  .Seal();
}}}

This support is actually a feature of `WeakJSClassCreator<>`, the
parent class of `ClassBinder`, but since `WeakJSClassCreator<>`
has no direct support for binding member functions (because it is
intentionally independent of the v8-juice core and therefore has no access to the
type conversions framework), this feature is only really accessible
via extensions or subclasses like `ClassBinder`.

In C++ and JS, we take it for granted that calling
`aSubTypeObject.vfunc()` would call the inherited virtual
function. However, when crossing JS/C++ boundaries, that feature does
not come for free. Since we use C++ templates to create the bindings
for classes, any conversions must know the _exact_ templatized type of
the native class. Because of this, `WeakJSClassCreator<ParentType>`
and `WeakJSClassCreator<SubType>` are, for purposes of typing (and in
particular for purposes of cross-JS/C++ conversions), unrelated, and
thus have no inherent implicit conversion ability.

When `WeakJSClassCreator<SubType>::Inherit()` is called, an internal
lookup function is added to `WeakJSClassCreator<ParentType>`, such
that calls to `WeakJSClassCreator<ParentType>::GetSelf()` (and
friends) will act "virtually". That is, if they cannot determine that
the JS object being converted is-exactly-a `ParentType` object, they
will use the internal lookup function to see if the object is an
instance of some other subclass of `ParentType`. Using this approach,
the member functions bound to `ParentType` can get a pointer to their
`this` object, even though the objects weren't created by
`WeakJSClassCreator<ParentType>`.

It is a _compile-time_ error to try to inherit either a base type for
which `WeakJSClassCreator<>` is not implemented or which is not a C++
base type of the wrapped type.

Any number of types may `Inherit()` a given base this way, and when
looking for a conversion they will be searched in an unspecified order
(but in theory only one can possibly match).

This approach has some limitations, the most glaring being that when we have more than
one level of inheritance, we must call `Inherit()` for each level of the hierarchy,
which is a real drag. i'm looking into other approaches which won't require this.

To inherit multiple levels deeply, we currently need to do the following:

{{{
struct TypeA
{...};
struct TypeB : TypeA
{...};
struct TypeC : TypeB
{...};

// When we bind TypeC:
typedef ClassBinder<TypeC> CB;
CB b( targetObject );
b.Inherit( binderForTypeB ); // sets up inheritance of TypeB
b.InheritNative<Type>(); // sets up inhertiance of TypeA
...
b.Seal();

// And we need to include the WeakJSClassCreator-CastOps.h
// supermacro, as shown above.
}}}

With that in place, JS-side `TypeC` objects will be able to convert their
native object to a `TypeB` or `TypeA` object, as needed, via the standard
type conversions mechanism.

==JS/C++ cast operations in the face of inheritance==

If we register the "standard" casting operators for a wrapped type using:

{{{
// must be in global-scope code
#define WEAK_CLASS_TYPE ParentType
#include <v8/juice/WeakJSClassCreator-CastOps.h>
#define WEAK_CLASS_TYPE SubType
#include <v8/juice/WeakJSClassCreator-CastOps.h>
}}}

(or equivalent)

then `CastToJS<ParentType>()` and `CastFromJS<ParentType>()` will use
`WeakJSClassCreator<ParentType>` for the conversions, and thus provide
the same "virtual" conversions to `SubType` objects. `SubType` objects
may then participate in type conversions which would normally apply
to `ParentType` objects (for this to work, each base has to be
`Inherit()`ed separately by its subclasses). This applies, for example, to the type conversions applied automatically to function arguments (as well as for the
`this` object) for bound member function and bound non-member functions.