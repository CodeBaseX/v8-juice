#summary Overview of the ClassBinder class

This is an extension of the [CreatingJSClasses page about creating JS classes]. Please read that page before reading this one. The page for the [ConvertingTypes v8::juice type conversions API] might also be helpful.

=!ClassBinder=

!ClassBinder is a WeakJSClassCreator subclass which makes use of
v8-juice's type conversions API to add features to the class binding process.
Unlike JSClassCreator and WeakJSClassCreator, !ClassBinder is not a
standalone implementation which can be used as-is in arbitrary v8 client
code - it requires the v8-juice type conversions framework.

The primary feature added by !ClassBinder is the ability to bind native
member functions of the wrapped type. The syntax for doing so is a tiny
bit odd, but there's a reason for it which we'll explain after we
demonstrate:

{{{
int MyClass::func( double ); // function we want to wrap


ClassBinder<MyClass> bin;
binder.AddMemFunc< int /* return value type */,
		double /* first arg type*/,
		&MyClass::func /* member func */
	>( "myFunc" );
}}}

_WTF?_ Every function-wrapping framework i've seen so far passes
function pointers as function arguments to the function templates (got
that?). In this one, we pass the function pointer as a _template
parameter_ instead of as a function argument! Why? It's ugly, but
there are reasons for it.

First, it is compile-time typesafe and this allows us to set up the
callbacks such that it is impossible to mis-cast a (`void*`) pointer
to a (`T*`) (in fact, no casts are used at all for this, even though
v8 internally gives us only (`void*`) handles).

Secondly, it costs us nothing at runtime. If we passed
pointers to functions as the arguments, we would have to create a
small wrapper object for _each_ binding (that is, one per class/member
combination), and the wrapper's only purpose would be to forward the
call to a specific native object (which is found at runtime of
course).  We would have no logical place to store the call-wrappers
for later cleanup (long story) and we would effectively introduce a
memory leak for every bound function.

By using function pointers as template parameters, we bind the
function pointers at compile time and therefor need no intermediary
call-proxy object instance. We _still_ have plenty of internal proxy
functions, but they require no dynamic memory and are bound (and
possibly inlined) at compile-time.

The primary down-side to this approach, as opposed to passing function
pointers as _function_ arguments (not _template_ arguments), is that the
function pointer signature's contained types must exactly match the
types specified in the other template parameters. e.g. the following
will not work:

{{{
int MyClass::func( double );

...

binder.AddMemFunc< int, // return value type
		int /* first arg type. Must be of type double because: */,
		&MyClass::func /* int (MyClass::*)(double) */
		>
		("func");
}}}

That won't work because the template type for the first member function
argument is wrong - it must the type used by the signature of the given
member function (so in this case it must be `double` instead of `int`).

If i'm not mistaken, if we bound at runtime to function pointers (via an
internal functor used as a call wrapper), we could rely on implicity
type conversions to do this sort of type conversions for us. That would,
however, require the above-mentioned leak, which i'm not at all keen on.

The conversion of member function parameters to/from JS is achieved
using the `v8::juice::convert` API, and this code inherits most of the type
conversion limitations (and features) of that API. As an exception, it supports
member functions returning `void` (which the `v8::juice::convert` API cannot
directly handle).

==Example of using !ClassBinder==

Here's an example of how `ClassBinder` can be used.

First we need a native type. Oh, look, here's one:

{{{
struct my_native
{
    int func1() { return 42; }
    int func2(int x) { return x*2; }
    double func3(int x,int y) { return x*y; }
    std::string hi() { return "hi!"; }
    my_native * me() { return this; }
    bool him(my_native * him) { return true; }
    void avoid() {}
    void avoid1(int x ) {}
    void avoid2(int x,double d ) {}
    double takes3(int x, int y, int z) { return x * y * z; }
};
}}}

Great, now that's out of the way. We need a
`WeakJSClassCreatorOps<my_native>` specialization which defines the
common binding operations:

{{{
namespace v8 { namespace juice {
    template <>
    struct WeakJSClassCreatorOps<my_native>
    {
    public:
	enum { ExtraInternalFieldCount = 0 };
	typedef my_native WrappedType;
	static char const * ClassName() { return "MyNative"; }
	static WrappedType * Ctor( Arguments const & argv,
				   std::string & exceptionText)
	{
            return = new my_native;
	}

	static void Dtor( WrappedType * obj )
	{
	    if( obj ) delete obj;
	}
    };
}} // namespaces
}}}

That example is feature-complete and ready for copy/paste into your source files.

The following macro hooks `my_native` in with the `v8::juice::convert`
API, so that we can use `CastToJS()` and `CastFromJS()` with
`my_native`. We want that in this case because some of the `my_native`
members take or return pointers to `my_native` objects. Since the
function forwarding mechanism uses `CastToJS()` and `CastFromJS()` for
all type conversions, we want to be able to hook in to that so that `my_native`
objects can also be cast:

{{{
#define WEAK_CLASS_TYPE my_native
#include <v8/juice/WeakJSClassCreator-CastOps.h>
}}}

(That must be called from global-scope code!)

That will generate the complete wrapper shown above. It can be included multiple times in the same
file. Each time it is included `WEAK_CLASS_TYPE` must be defined anew, as the header file
`#undef`s it on each call to `#include`.

If the native type will never be passed as a parameter or returned
from a function (i.e. it will only be the `this` object) then these
conversions are not strictly required.

For the extremely curious, that macro generates something like the following:

{{{
namespace v8 { namespace juice { namespace convert {
template <>
struct NativeToJS<my_native>
{
    Handle<Value> operator()( my_native * p ) const
    {
	Handle<Object> jo = ::v8::juice::WeakJSClassCreator<my_native>::GetJSObject(p);
	if( jo.IsEmpty() ) return Null();
	else return jo;
    }
};
template <>
struct JSToNative<my_native>
{
    typedef my_native * result_type;
    result_type operator()( Handle<Value> const & h ) const
    {
	return ::v8::juice::WeakJSClassCreator<my_native>::GetNative(h);
    }
};
} } } // namespaces
}}}

(See the [ConvertingTypes type conversions page] for the details.)

And now what we originally set out to to: bind `my_native` with JS:

{{{
    typedef ClassBinder<my_native> WT;
    WT w( v8::Context()->GetCurrent()->Global() );
    typedef my_native MY;
    w.Set("prop1", String::New("this is my first property"))
      .Set("answer", Integer::New('*'));
    w.BindMemFunc< int, &MY::func1>( "func1" )
     .BindMemFunc< int, int, &MY::func2 >( "func2" )
     .BindMemFunc< std::string,&MY::hi >( "hi" )
     .BindMemFunc< MY *,&MY::me >( "me" )
     .BindMemFunc< bool,MY *,&MY::him >( "him" )
     .BindMemFunc< double,int,int,&MY::func3 >( "func3" )
     .BindMemFunc< void,&MY::avoid >( "avoid" )
     .BindMemFunc< void,int,&MY::avoid1 >( "avoid1" )
     .BindMemFunc< void,int,double,&MY::avoid2 >( "avoid2" )
     .BindMemFunc< double,int,int,int,&MY::takes3 >( "takes3" );
    w.Seal();
}}}

Again, it's ugly, but it also has no extra runtime memory costs other than that needed by
the v8 internals and the conversion from JS to native. While it isn't demonstrated here, `const` member functions can also be bound, as can member _variables_
(see `v8::juice::WrappedMemVarGetter<>()` and `v8::juice::WrappedMemVarSetter<>()`).

And in JS it looks like this:

{{{
var m = new MyNative();
print('void returns:',m.avoid(),m.avoid1(32),m.avoid2(17,11));
print(m.hi());
print(m.func3(m.func1(),m.func2(m.func1())))
print(m.him(m));
print(m.me());
print(m.takes3(2,2,3));
}}}

The output:

{{{
stephan@jareth:~/cvs/v8-juice/trunk/src/client/shell$ ./v8-juice-shell js/fwd.js
void returns: undefined undefined undefined
hi!
3528
true
[object Object]
12
}}}

An interesting feature of the class binding framework is that it's compile-time typesafe. Though v8 uses `void *` as the parameter type for destruction callbacks, the implementation uses a mix of class templates, private static functions, and an internal void-to-native mapping to ensure that only the correct types can, e.g., be passed to the correct destructor, and that `CastFromJS<TypeB>()` cannot cast (using the default conversions) to `TypeA`. The implementation is believed to be 100% typesafe.
