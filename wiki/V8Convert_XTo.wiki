#summary V8Convert's "XTo" API
#labels Phase-UserDocs,Topic-CPlusPlus

See also: [V8Convert_Overloading], [V8Convert_PropertyBinding], [V8Convert_FunctionBinding]


If the [V8Convert_ClassCreator overwhelming] [V8Convert_Overloading number] of [V8Convert_TipsAndTricks options] for [V8Convert_FunctionBinding binding functions], [V8Convert_FunctionBinding methods], and [V8Convert_PropertyBinding properties] in cvv8 has got you down, here's something which might lighten your day: you only need to learn 3 simple templates.

On the rainy day of 20110724, during a testing/debugging chat session, Coen Champman suggested a "kinda weird" syntax for doing "x-to-v8" conversions, particularly in the context of function and variable binding. His suggestion was to wrap all function-to-X in a single template named `Function`, all property-getter-to-X to another template, and so on. He proposed that we pass a tag type as the first argument to the template to specify exactly which conversion we wanted to perform.

Kinda strange, i know, but his pasted-in hypothetical usage example intrigued me, and 50 lines of code later we had a working version. (All of the code is compile-time only - no additional runtime overhead is added.)

In client code it looks something like this:

{{{
int aBoundInt = 3;
void test_xto_bindings()
{
    v8::InvocationCallback cb;
    v8::AccessorGetter g;
    v8::AccessorSetter s;

    using namespace cvv8;

    // Function-to-X conversions:
    cb = FunctionTo< InCa, int(char const *), ::puts>::Call;
    cb = FunctionTo< InCaVoid, int(char const *), ::puts>::Call;
    g = FunctionTo< Getter, int(void), ::getchar>::Get;
    s = FunctionTo< Setter, int(int), ::putchar>::Set;

    // Var-to-X conversions:
    g = VarTo< Getter, int, &aBoundInt >::Get;
    s = VarTo< Setter, int, &aBoundInt >::Set;
    typedef VarTo< Accessors, int, &aBoundInt > VarGetSet;
    g = VarGetSet::Get;
    s = VarGetSet::Set;

    // Method-to-X conversions:
    typedef BoundNative T;
    cb = MethodTo< InCa, T, void (), &T::doFoo >::Call;
    cb = MethodTo< InCa, const T, int (), &T::getInt >::Call;
    cb = MethodTo< InCaVoid, const T, int (), &T::getInt >::Call;
    g = MethodTo< Getter, const T, int (), &T::getInt >::Get;
    s = MethodTo< Setter, T, void (int), &T::setInt >::Set;

    // Functor-to-X conversions:
    typedef MyFunctor F;
    cb = FunctorTo< InCaVoid, F, bool () >::Call;
    cb = FunctorTo< InCa, F, bool (int) >::Call;
    g = FunctorTo< Getter, F, bool () >::Get;
    s = FunctorTo< Setter, F, void (bool) >::Set;
}
}}}

While the syntax is a bit unconventional, i find it to be quite readable, writable, and easy to remember how to use. And we can extend it as new conversions come up, e.g. `MethodTo<Monkey,... >`.