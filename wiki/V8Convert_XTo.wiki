#summary V8Convert's "XTo" API
#labels Phase-UserDocs,Topic-CPlusPlus

See also: [V8Convert_Overloading], [V8Convert_PropertyBinding], [V8Convert_FunctionBinding]

<wiki:toc/>

=Introduction=

If the [V8Convert_ClassCreator overwhelming] [V8Convert_Overloading number] of [V8Convert_TipsAndTricks options] for [V8Convert_FunctionBinding binding functions], [V8Convert_FunctionBinding methods], and [V8Convert_PropertyBinding properties] in cvv8 has got you down, here's something which might brighten your day: you only need to learn 3 simple templates.

On the rainy day of 20110724, during a testing/debugging chat session, Coen Champman suggested a "kinda weird" syntax for doing "x-to-v8" conversions, particularly in the context of function and variable binding. His suggestion was to wrap all function-to-X conversions in a single template named `Function`, saying that we could pass a tag type as the first argument to the template to specify exactly which conversion we wanted to perform.

Kinda strange, i know, but his pasted-in hypothetical usage example intrigued me, and 50 lines of code later we had a working version. (All of the code is compile-time only - no additional runtime overhead is added.)

In client code it abstractly looks something like this:

{{{
int aBoundInt = 3;
void test_xto_bindings()
{
    v8::InvocationCallback c;
    v8::AccessorGetter g;
    v8::AccessorSetter s;

    using namespace cvv8;

    // Function-to-X conversions:
    c = FunctionTo< InCa, int(char const *), ::puts>::Call;
    c = FunctionTo< InCaVoid, int(char const *), ::puts>::Call;
    g = FunctionTo< Getter, int(void), ::getchar>::Get;
    s = FunctionTo< Setter, int(int), ::putchar>::Set;

    // Var-to-X conversions:
    g = VarTo< Getter, int, &aBoundInt >::Get;
    s = VarTo< Setter, int, &aBoundInt >::Set;
    typedef VarTo< Accessors, int, &aBoundInt > VarGetSet;
    g = VarGetSet::Get;
    s = VarGetSet::Set;

    typedef BoundNative T;

    // Member Var-to-X conversions:
    g = MemberTo< Getter, T, int, &T::publicInt >::Get;
    s = MemberTo< Setter, T, int, &T::publicInt >::Set;
    typedef MemberTo< Accessors, T, int, &T::publicInt > MemAcc;
    g = MemAcc::Get;
    s = MemAcc::Set;
    

    // Method-to-X conversions:
    c = MethodTo< InCa, T, void (), &T::doFoo >::Call;
    c = MethodTo< InCa, const T, int (), &T::getInt >::Call;
    c = MethodTo< InCaVoid, const T, int (), &T::getInt >::Call;
    g = MethodTo< Getter, const T, int (), &T::getInt >::Get;
    s = MethodTo< Setter, T, void (int), &T::setInt >::Set;

    // Functor-to-X conversions:
    typedef MyFunctor F;
    c = FunctorTo< InCaVoid, F, bool () >::Call;
    c = FunctorTo< InCa, F, bool (int) >::Call;
    g = FunctorTo< Getter, F, bool () >::Get;
    s = FunctorTo< Setter, F, void (bool) >::Set;
}
}}}

While the syntax is a bit unconventional, i find it to be quite readable, writable, and easy to remember how to use. And we can extend it as new conversions come up, e.g. `MethodTo<Monkey,... >`.

Side note:

The above example incidentally shows, however indirectly, essentially every feature [V8Convert] offers except for [V8Convert_ClassCreator class binding]:

  * Converting functions, methods, and functors to `v8::InvocationCallback`, `v8::AccessorGetter`, and `v8::AccessorSetter`. (That's 9 different conversion combinations, or 12 if we consider that `const` methods are internally handled separately.)
  * Proxying JS property access directly to a native non-member variable or static non-function member (`VarTo<>`), or to non-static non-function members (`MemberTo<>`).
  * Type conversions happen implicitly all throughout the function/property-binding process, so those are also (indirectly) demonstrated here.

Though it might not look like much, the templates shown above are built on top of virtual _mountains_ (well, _hills_) of lower-level functionality which clients can also use.

=Conventions=

The demonstration in the first section shows everything one really needs to know about using this API. Here we'll go into a bit more detail...


The common conventions used by this API are:

  * The conversion templates are all named like `XyzTo`.
  * The first argument to the template is a "tag" type. The tag types each correspond to a distinctly different type of conversion. The tags are:
    * `InCa`: converts to a `v8::InvocationCallback`
    * `InCaVoid`: converts to a `v8::InvocationCallback` which does not evaluate the return type (see [V8Convert_FunctionBinding] for why/when this is useful).
    * `Getter`: converts to a `v8::AccessorGetter`
    * `Setter`: converts to a `v8::AccessorSetter`
    * `Accessors`: is a combination of `Getter` and `Setter`.

The arguments after the first depend on the main "target" of the conversion (e.g. a function, method, or functor), and for a given "target", the template arguments after the tag type are the same regardless of the tag's value. They can be summarized like:

  * `FunctionTo< TagType, signature, function_ptr_matching_signature [, UnlockV8=a_bool_value]>`
  * `MethodTo< TagType, T, signature, method_ptr_matching_signature [, UnlockV8=a_bool_value]>` (use const-qualified `T` for const methods!)
  * `FunctorTo< TagType, signature_of_operator() [, UnlockV8=a_bool_value]>`
  * `VarTo< TagType, PropertyType, ptr_to_property>`
  * `MemberTo< TagType, T, PropertyType, ptr_to_member_property>`

You can read more about the meaning of the `UnlockV8` option on the [V8Convert_FunctionBinding] page. (It has a sane default for _most_ cases, and can normally ignored.)

The expanded templates evaluate to types which contain a specific function, depending on the conversion tag type:

  * `InCa` and `InCaVoid`: `Call()`, implementing the `v8::InvocationCallback` interface.
  * `Getter`: `Get()`, implementing the `v8::AccessorGetter` interface.
  * `Setter`: `Set()`, implementing the `v8::AccessorSetter` interface.
  * `Accessors`: as for `Getter` and `Setter` combined.

Note that not all targets support all tags. e.g. there no `FunctionTo<Accessors,...>` because a function signature can only ever match either a getter _or_ a setter. Trying to use invalid conversions will lead to compile-time errors.