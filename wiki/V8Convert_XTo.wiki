#summary V8Convert's "XTo" API
#labels Phase-UserDocs,Topic-CPlusPlus

See also: [V8Convert_Overloading], [V8Convert_PropertyBinding], [V8Convert_FunctionBinding]


If the [V8Convert_ClassCreator overwhelming] [V8Convert_Overloading number] of [V8Convert_TipsAndTricks options] for [V8Convert_FunctionBinding binding functions], [V8Convert_FunctionBinding methods], and [V8Convert_PropertyBinding properties] in cvv8 has got you down, here's something which might brighten your day: you only need to learn 3 simple templates.

On the rainy day of 20110724, during a testing/debugging chat session, Coen Champman suggested a "kinda weird" syntax for doing "x-to-v8" conversions, particularly in the context of function and variable binding. His suggestion was to wrap all function-to-X conversions in a single template named `Function`, saying that we could pass a tag type as the first argument to the template to specify exactly which conversion we wanted to perform.

Kinda strange, i know, but his pasted-in hypothetical usage example intrigued me, and 50 lines of code later we had a working version. (All of the code is compile-time only - no additional runtime overhead is added.)

In client code it abstractly looks something like this:

{{{
int aBoundInt = 3;
void test_xto_bindings()
{
    v8::InvocationCallback c;
    v8::AccessorGetter g;
    v8::AccessorSetter s;

    using namespace cvv8;

    // Function-to-X conversions:
    c = FunctionTo< InCa, int(char const *), ::puts>::Call;
    c = FunctionTo< InCaVoid, int(char const *), ::puts>::Call;
    g = FunctionTo< Getter, int(void), ::getchar>::Get;
    s = FunctionTo< Setter, int(int), ::putchar>::Set;

    // Var-to-X conversions: (non-member variables and static non-function members)
    g = VarTo< Getter, int, &aBoundInt >::Get;
    s = VarTo< Setter, int, &aBoundInt >::Set;
    typedef VarTo< Accessors, int, &aBoundInt > VarGetSet;
    g = VarGetSet::Get;
    s = VarGetSet::Set;

    // Method-to-X conversions:
    typedef BoundNative T;
    c = MethodTo< InCa, T, void (), &T::doFoo >::Call;
    c = MethodTo< InCa, const T, int (), &T::getInt >::Call;
    c = MethodTo< InCaVoid, const T, int (), &T::getInt >::Call;
    g = MethodTo< Getter, const T, int (), &T::getInt >::Get;
    s = MethodTo< Setter, T, void (int), &T::setInt >::Set;

    // Functor-to-X conversions:
    typedef MyFunctor F;
    c = FunctorTo< InCaVoid, F, bool () >::Call;
    c = FunctorTo< InCa, F, bool (int) >::Call;
    g = FunctorTo< Getter, F, bool () >::Get;
    s = FunctorTo< Setter, F, void (bool) >::Set;
}
}}}

While the syntax is a bit unconventional, i find it to be quite readable, writable, and easy to remember how to use. And we can extend it as new conversions come up, e.g. `MethodTo<Monkey,... >`.

Side note:

The above example incidentally shows, however indirectly, essentially every feature [V8Convert] offers except for [V8Convert_ClassCreator class binding]:

  * Converting functions, methods, and functors to `v8::InvocationCallback`, `v8::AccessorGetter`, and `v8::AccessorSetter`. (That's 9 different conversion combinations.)
  * Proxying JS property access directly to a native non-member variable or static non-function member.
  * Type conversions happen implicitly all throughout the function/property-binding process, so those are also (indirectly) demonstrated here.

Though it might not look like much, the templates shown above are built on top of virtual _mountains_ (well, _hills_) of lower-level functionality which clients can also use.