#summary Converting between JS and native types
#labels Phase-UserDocs,Topic-CPlusPlus

<wiki:toc max_depth="3" />

= An introduction to the `v8::juice::convert` API =

Juice comes with an API for casting between JS types and native types. While v8 of course provides convenience routines like `Value::IntegerValue()` and `Value::ToString()`, that leaves us with two limitations:

  * The types of conversions are defined by v8's implementors and are not extensible.
  * We have to know the exact conversion routine we want to call. Believe it or not, when our code uses typedefs (e.g. numeric types of unspecified sizes, possibly from external libraries) we cannot safely know which conversion to rely upon.

And thus we let C++ templates decide it for us...

{{{
#include <v8/juice/convert.h>

...
namespace cv = ::v8::juice::convert;
using namespace v8;

int i = cv::CastFromJS<int>(someJSVal);
std::string s = cv::CastFromJS<std::string>(someJSVal);
double d = cv::CastFromJS<double>(someJSVal);
...

Handle<Value> v1 = cv::CastToJS( myInteger );
Handle<Value> v2 = cv::CastToJS( "hi, world" );
Handle<Value> v3 = cv::CastToJS( myType ); // we can add custom conversions!
}}}


The `CastToJS()` and `CastFromJS()` routines are very small functions which
delegate all work to template a specialization of the class `NativeToJS<>`
resp. `JSToNative<>`. Specializations are already installed for all of the
base POD types (except (`char const *`) - see below), and clients can provide
their own to do any conversion they like. An example of this is shown on
[CreatingJSClasses the creating-new-classes page].


For those averse to template arguments, there are a number of convenience instantiations of the `NativeToJS` template which can be used like this:

{{{
  int32_t i = JSToInt32(...);
  std::string s( JSToStdString(...) );
  bool b = JSToBool(...);
}}}


=Implementing custom conversions=

==Achtung: not for noobs==

Forewarning: customizing the type conversions requires a fair amount of
knowledge in how to use and abuse C++ templates. DO NOT just blindly
copy/paste some example from this page without understanding what it does and
how it gets triggered. One tiny little typing mistake can lead to literally
hundreds of lines of compiler error messages (or weird link errors), and it
often takes patience and experience to be able to decypher such problems
("dammit, it's a pointer, not a reference").

Good luck!

==Custom native-to-JS conversions==

To make our own types support work with `CastToJS()` we have to provide
template specialization for `NativeToJS<>`, as shown below.

{{{
namespace v8 { namespace juice { namespace convert {
template <>
struct NativeToJS<MyType>
{
    Handle<Value> operator()( MyType const * n ) const
    {
        // This impl works together with WeakJSClassCreator():
        return ::v8::juice::WeakJSClassCreator<MyType>::GetJSObject( n );
    }
};
} } } // namespaces
}}}


The important thing is that this specialization is available before
any client code calls (however indirectly) `CastToJS<MyType>(...)`. If it is not,
the compiler will try to pick up another instantiation of the template. With luck
it will fail loudly, but (and this depends on `MyType`) it may pick up a different,
inappropriate converter.


==Custom JS-to-native conversions==

The converse of `NativeToJS<>` is of course `JSToNative<>`:

{{{
namespace v8 { namespace juice { namespace convert {
template <>
struct JSToNative<MyType>
{
    typedef MyType * result_type;
    result_type operator()( Handle<Value> const & h ) const
    {
       // This impl works together with WeakJSClassCreator():
       return ::v8::juice::WeakJSClassCreator<MyType>::GetNative( h );
    }
    // This overload is an evolutionary artefact and will likely be removed from the API at some point:
    result_type operator()( ::v8::juice::bind::BindKeyType, Handle<Value> const & jv ) const
    {
        return this->operator()( h );
    }
};
} } } // namespaces
}}}



=The `(char const *)` problem=

The following will work as expected:

{{{
Handle<Value> v = CastToJS("this is a (char const *)");
}}}

This won't:

{{{
char const * v = CastFromJS(myJSVal);
}}}

The problem here is ownership and lifetime of the string bytes. v8 does not document them (and can't realistically provide any requirements which we would need for this conversion). We _can_ write a conversion routine for this, and it would probably work 99% of the time, but its results would technically be undefined. As a workaround, client code should use `std::string` instead (at least for `CastFromJS()`) or implement `JSToNative<>` and/or `NativeToJS<>` specializations for their string type of choice. The `CastToJS()` function is overloaded for (`char const *`) and "does the right thing", but `CastFromJS()` cannot handle such strings as transparently as it can most other types.

=Silly Examples=

Here are some examples of the things one can do with the type conversions API:

{{{
std::list<int> li;
... populate list ...
Handle<Value> v( CastToJS( li ) ); // Array of strings
}}}

That will work for _any_ list-contained type which is supported by the casting API. Ergo:

{{{
typedef list<std::string> StringList;
typedef list<StringList> ListList;
ListList li;
... populate li ...
Handle<Value> v( CastToJS( li ) ); // Array of Arrays of strings
}}}

And that means that we can use `ClassBinder` to bind to member functions which take or return arguments of those types, too.

And how about:

{{{
StringList sl = CastFromJS<StringList>( someJSVal );
}}}

That will result in a populated list, but only if `someJSVal` is-an object of Array type. If it is, each entry in the array will be cast using `CastFromJS<StringList::value_type>()`.

See <tt>[http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/convert.h convert.h]</tt> for how such conversions are implemented (search that file for `ListT`).