#summary Overview of the ClassWrap API
#labels Topic-CPlusPlus,Phase-UserDocs

*ACHTUNG: this page documents a new API and is far from complete.* The `ClassWrap` API was introduced on 20091025 - it is quite new and may still change significantly.

<wiki:toc max_depth='3'/>

=!ClassWrap =

!ClassWrap is a `JSClassCreator` subclass which makes use of
v8-juice's type conversions API to add features to the class binding
process.

!ClassWrap is an alternate API to ClassBinder for binding native
classes to JS. Where ClassBinder is "monolithic", !ClassWrap is
policy-based. That is, it implements only the most basic binding options, leaving the real work
to various policy classes. Policy classes can be specialized for a given
type to provide additional features, and sensible defaults are installed
whenever possible.

These docs assume that the reader is familiar with the
[ConvertingTypes v8::juice type conversions API], and those docs
may be helpful in understanding these docs.

The source code and API documentation for this class is in:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap.h ClassWrap.h]

Some related materials:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap_JuiceBind.h ClassWrap_JuiceBind.h]
  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/ClassWrap_TwoWay.h ClassWrap_TwoWay.h]


=An example Class=

For the demonstrations below we will use the following class:

{{{
struct BoundNative
{
public:
    static bool enableDebug;
private:
    static size_t instcount;
    int propi;
public:
    double publicProperty;
    BoundNative();
    explicit BoundNative( int i, double d = 42.24 );
    virtual ~BoundNative();
    bool ptr( BoundNative const * b );
    BoundNative * getPtr();
    static size_t InstanceCount();
    int getInt() const;
    void setInt( int i );
    bool overload() const;
    int overload(int i);
    double overload(int i, double d);
    virtual std::string toString() const;
};

}}}

Now let's see how to "bind" various aspects of `BoundNative`
into JS...

=Setting up the basic policies=

Part of binding our class using this framework involves setting
up various so-called "policy" classes. We won't go into detail
here about what they are and which ones exist. Instead we will
set up only the policies we need.

All of the policy classes must be specialized within the
`v8::juice::cw` namespace, but for brevity that namespace will
be left out of examples. The example code also assumes that
`using namespace v8::juice` is in effect.

== Factory policy ==

The Factory policy's responsibilities are creating and destroying
new instances of objects. It is one of the few policies for which
there is no default implementation. There are several base Factory
types which we can use to install construction/destruction support,
and we will use one of those bases here.

`BoundNative` has several constructors. Which one shall we
bind to JS? Don't bother trying to decide - we'll bind all of them.

{{{
template <>
struct Factory<BoundNative>
    : Factory_CtorForwarder<BoundNative,
        convert::TypeList<
            convert::CtorForwarder0<BoundNative>,
            convert::CtorForwarder1<BoundNative,int>
            convert::CtorForwarder2<BoundNative,int,double>
        >
      >
{};
}}}

Notice that we bound the two-arg ctor twice. Because it has a default
value for the second argument, we can bind it as a one- and/or two-arg
constructor.

If we wanted to customize the construction process we would specialize
`Factory<BoundNative>` and implement the `cw::Factory` policy's
interface (two functions and one constant).

== Class name ==

The !ClassName policy defines a bound class's JS-side name. It looks like:

{{{
template <>
struct ClassName<BoundNative>
{
    static char const * Value()
    {
        return "BoundNative";
    }
};
}}}

Alternately, we can call the following macro from the global scope:

{{{
JUICE_CLASSWRAP_CLASSNAME(BoundNative,"BoundNative");
}}}

which generates the above code.

Some policy sets provide this feature as part of their setup.

= Initializing !ClassWrap =

We need to initialize our class bindings somewhere. Conventionally
that looks something like this:

{{{
v8::Handle<v8::Object> SetupBoundNativeClass( v8::Handle<v8::Object> dest )
{
    typedef ClassWrap<BoundNative> CW;
    CW & b( CW::Instance() );

   // ... binding code goes here (see later examples) ...

   b.Seal(); // ends the binding process
   b.AddClassTo( dest ); // installs BoundNative class in dest
   return b.CtorTemplate()->GetFunction();
}
}}}

=Binding functions=

We can bind both `BoundNative` member functions and free functions
to the JS class using the power of C++ templates.

From our `SetupBoundNativeClass()` routine:

{{{
typedef convert::MemFuncInvocationCallbackCreator<BoundNative>
        ICM; // typing-saver
b.Set( "toString",
        ICM::M0::Invocable<std::string,&BoundNative::toString> );
b.Set( "setInt",
        ICM::M1::Invocable<void,int,&BoundNative::setInt );
b.Set( "getInt",
        ICM::M0::Invocable<int,&BoundNative::getInt> );

}}}

The `ICM` class is a utility class which saves a few bytes of typing.
The `ICM::M0` to `ICM::M9`, and `ICM:F0` to `ICM::F9` are
convenience typedefs for assisting in binding member (thus the M)
functions taking the given number of arguments.

We can also bind non-member native functions as JS members using
a similar approach:

{{{
typedef convert::InvocationCallbackCreator ICC; // typing-saver
b.Set( "sleep",
       ICC::F1::Invocable<unsigned int,unsigned int,::sleep> );
}}}

This templates _create_ functions which implement the `v8::InvocableCallback`
interface. The generated functions use the [ConvertingTypes type conversion API]
to convert their arguments from their native counterparts and convert
the return value to a native value (or JS `undefined` for `void` return types).

=Binding member variables=

We can bind native member variables to JS space, such that all
get/set access is directed through the native variables. Alternately,
we can bind JS properties to native getter/setter functions, such that
all access to the property goes through those accessors.

This requires a slightly different approach than binding
functions:

{{{
typedef convert::PropertyBinder<BoundNative> PB;
v8::Handle<v8::ObjectTemplate> cwproto = b.Prototype();

// Bind BoundNative.myInt to BoundNative::getInt() and BoundNative::setInt():
PB::BindGetterSetter<int,
                     &BoundNative::getInt,
                     void,int,&BoundNative::setInt>
                     ( "myInt", cwproto );

// Bind BoundNative.intGetter read-only to BoundNative::getInt()
PB::BindGetter<int,&BoundNative::getInt>( "intGetter", cwproto );

// Bind BoundNative.publicProperty to BoundNative::publicProperty:
PB::BindMemVar<double,
              &BoundNative::publicProperty>
              ( "publicProperty", cwproto );

// Bind BoundNative.publicPropertyRO read-only to BoundNative::publicProperty:
PB::BindMemVarRO<double,
                 &BoundNative::publicProperty>
                 ( "publicPropertyRO", cwproto );
}}}

(TODO: add convenience funcs for those in the !ClassWrap interface.)

We can also bind JS properties to static variables, using `PB::BindStaticVar()`.

= Caveats and Gotchas =


== Inheritance doesn't come for free ==

Crossing the JS/C++ lines poses several problems for bound classes.

The more glaring ones are:

  * JS-side subclass complicate the lookup of the native `this` pointer which is stored internally in the JS object.
  * When one bound type inherits another, inherited bound native functions called from the subclass may not be able to find their own `this` pointer because the subtype is not exactly the same type as the parent.


The good news is that there are ways around these problems, and the default !ClassWrap
policies try to make these problems go away to the best of their ability.

TODO: document this when you're less tired.

==Achtung: Beware of Copies!==

Consider the following members:

{{{
typedef std::list<std::string> StringList;
StringList MyClass::getList() const;
void MyClass::setList( StringList const & );
}}}

These can be bound to a member, such that getting the member via JS
would return an Array of String object, and setting it would convert
the value to an Array of Strings. That's all fine and good, but
be very aware that that particular conversion _requires copying list_.
The two main implications are that (1) such access may not be cheap,
depending on the conversion necessary for the getter/setter,
and (2) the following _will not work in an intuive manner_:

{{{
var ar = ["hi", "world" ];
myobj.list = ar; // COPIES ar!
ar.push("!"); // does NOT modify myobj.list
// myobj.list.length == 2
// ar.length == 2
}}}

Thus it is not generically possible to update JS references
via this approach.

That said, the following is kosher _if_ a specialization
of the !ClassWrap `ToJS<>` policy is in place to convert
from natives to JS. (Such support requires extra tooling in the
policy classes, and the `ClassWrap_TwoWay.h` policy set
provides this.)

{{{
MyClass * MyClass::getBuddy();
void MyClass::setBuddy( MyClass * );
...
PB::BindGetterSetter<MyClass *,
                     &MyClass::getBuddy,
                     void,MyClass *,&MyClass::setBuddy>
                     ( "buddy", b.Prototype() );

// JS:
var o1 = new MyClass();
o1.buddy = new MyClass(); // calls MyClass::setBuddy(new object)
...
print( o1.buddy ) // will act on that same MyClass instance.
}}}

Getting/setting such a property via these bindings will work
as expected as long as the property refers to another
bound `MyClass` object.

_HOWEVER_, there is another caveat: in the above specific case, we "should"
give JS an explicit handle to the newly-created object or we risk it getting
garbage collected because the native member conversions to not store a
reference to the new object in JS space (only in native space). Thus it is
possible, in the above example, that calling `o1.buddy` in a "get" context
would return null or an empty object if GC is called between the assignment
and the call to `print()`.

The general workaround for this problem is to stuff a reference to the
new object somewhere:

{{{
o1._refs = [];
o1.buddy = (o1._refs[o1._refs.length] = new MyClass());
...
print( o1.buddy ); // this is now safe
}}}

That is somewhat lame, but it is a generic problem for many types of
JS-to-Native bindings. (When i first encountered it, it took me an hour
to figure out why my new objects kept disappearing.)


==Return values of native setter members==

Be aware that the return value of a native setter function is
_ignored_ for binding purposes because that's how the JS API works in
regards to assignment.  This example should clarify:

{{{
myobj.prop = 12; // MyClass::setProp(12)
print( myobj.prop += 3 ); // is essentially (but not exactly) equivalent to:
// print(
//      ( MyClass::setProp( MyClass::getProp() + 3 ),
//        MyClass::getProp() )
// );
// (Recall that (a,b,c...) evaluates to the last expression in the list)
}}}

In actuality `getProp()` is not called a second time in the `print()`
expression (though i'm honestly not entirely sure why not), but the
effect is essentially as if it is called (assuming the getter has no
side effects which would affect the second call).

Thus the assignment operation returns the JS-internal value of the
assignment, and _not_ the return value of `MyClass::setProp()`. This
is a property (feature or limitation?) of the v8 property accessor
binding API.

=Example of using !ClassWrap=

The complete test/demo code for !ClassWrap can be found here:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/client/sample/BoundNative/BoundNative.cpp BoundNative.cpp]