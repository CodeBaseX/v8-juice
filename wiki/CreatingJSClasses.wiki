#summary Creating JS classes from C++
#labels Phase-UserDocs,Featured

<wiki:toc max_depth="3" />

=Introduction=

The library has (as of [http://code.google.com/p/v8-juice/source/detail?r=167 r167], 20090310), support for creating custom JS classes using minimal code.

The JSClassCreator and !WeakJSClassCreator classes are helpers which encapsulate
much of the drudge work associated with binding a native class to JS. This page
describes how to use them.

This API is likely to be continually tweaked, so if you use this API be prepared for changes down the road.

==Getting the source code==

While this code is part of v8-juice, its implementation is independent of any other
library components, which means it be extracted from the v8-juice source tree for use in other v8-based projects. The source files are:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/JSClassCreator.h JSClassCreator.h]
  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/juice/JSClassCreator.cc JSClassCreator.cc]
  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/WeakJSClassCreator.h WeakJSClassCreator.h]

=JSClassCreator=

The base binding class, JSClassCreator is suitable for creating new JS classes which do not need to link to a specific native instance, or want (or need) to do their own handling binding/unbinding of those instances. The WeakJSClassCreator subclass adds the ability to automatically handle the binding/unbinding of a native object to/from the garbage collection system (in v8 this is called a "weak persistent pointer").

{{{
// JS-side constructor for MyClass objects...
Handle<Value> MyClass_ctor( Arguments const & argv );

// In your JS init code:
JSClassCreator binder( "MyClass", // JS class name
		targetObject, // "global" object (the class we be installed here)
		MyClass_ctor, // constructor callback
		1 ); 	// # of internal fields to reserve
binder.Set( "funcOne", my_callback_func )
      .Set( "valOne", String::New("hi there!") )
      ... more setters ...
      .Seal(); // Seal() MUST come last!
}}}

With the JSClassCreator, the client is responsible for:

  * In the ctor, put your native somewhere where member native functions can get to it (e.g. put it in an Internal field in the JS new object).
  * In member functions, extract the native element as needed.

Once that's in place we can:

{{{
var obj = new MyClass(...);
}}}

For the most basic cases, that's all that necessary, in terms of C++ setup. However, the most significantly missing feature of !MyClass is memory management. v8 provides a callback mechanism with which we can be notified "when a context no longer needs an object." The callback mechanism is, due to v8 design decisions, not 100% reliable (there is never a _guaranty_ that our callback will be called!), which makes it useless as a basis for resource management when destructors of certain types _must_ be called to avoid resource leaks, data corruption, etc.

=Backing up a bit: the garbage collection problem=

Let's back up a moment and describe the overall problem:

When an object is created in JavaScript, there is normally no client-visible "native" component to that value - it is an opaque type defined by v8, and has no visible association with a native value. That's all fine and good because the JS engine takes care of cleaning up those objects when it no longer needs them. When "binding" native classes to JS, we invariably associate a JS class with an instance of a C++ class (or some other native type - it need not be a class, e.g. it may be an opaque pointer type from a third-party C library). To do such bindings effectively we need several components:

  * A way to internally associate the native data with the JS object. In v8 this is done using `v8::Object::SetInternalField()` and the `v8::External` type. In fact, `v8::External` is the _only_ option for us here, because it is the only v8 type for which we can get a stable unique-per-process value (`External::Value()`), and having some sort of lookup key (in this case a void pointer) is an essential component of binding classes.
  * We "should" have a way to be notified when the JS part of an object is destroyed. In v8 this is accomplished by registering a "weak pointer" callback with the JS object. That callback will be called when (_if_) the v8 GC decides that there are no JS-side references to the object. When this callback is triggered, we can take care of properly deleting the native object and unbinding it from JS-land.

In practice there are a few wrinkles in that story, but we will skip over those now for the sake of clarity, and will touch on them again later on.

The documentation for v8's weak pointers support is a bit spotty, and one can easily spend hours experimenting before the first attempts at class wrapping work. Or we can use WeakJSClassCreator, which was authored after many hours of painful experimentation and sorting through the vague documentation regarding weak pointers in v8...

=WeakJSClassCreator=

The WeakJSClassCreator is a JSClassCreator subclass which uses C++
templates to create functions for binding and unbinding JS objects
to/from native objects of a given type. It is based on the v8 "weak
persistent pointers" concept, and thus its odd name. It is used mostly
like JSClassCreator, the notable difference being a template
argument. As a template argument it takes a native type on whos behalf
it should act. In addition, we need a `WeakJSClassCreatorOps<MyType>` 
class template specialization, which is described fully in the API docs
and briefly shown here:

{{{
namespace v8 { namespace juice {
    template <>
    struct WeakJSClassCreatorOps<MyClass>
    {
	/** The actual wrapped native type (may differ from the
            template arg in some cases!). */
	typedef MyClass WrappedType;

	/** Number of internal JS Object fields client needs for
	    his own use. */	
	enum { ExtraInternalFieldCount = 0 };

	/** Constructor function. */
	static WrappedType * Ctor( Arguments const &  /*argv*/,
				   std::string & /*exceptionText*/);

	/** Destructor function. */
	static void Dtor( WrappedType * obj );
    };
}} // namespaces
}}}

Again, their semantics are documented in full
[http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/WeakJSClassCreator.h in the source code].

In brief:

  * The constructor is responsible for trying to create a `MyClass` object from the given arguments, but it is _not_ responsible for binding that native to the JS object. If it cannot create a new object, it must return 0 and may optionally put some descriptive error string in the given string reference (note that it is not const!), and the internal handler provided by WeakJSClassCreator will convert the error text into a JS-side exception. On success, the ctor must return a new instance of the native object. The internals of WeakJSClassCreator will then bind that native to JS using the weak pointer callback mechanism.
  * The destructor function must destroy the object using some type-specific logic. Note that it may be called from the weak pointer trigger or it may be called via client-side action (e.g. a `close()` function for a given type might want to destroy the native object).

Now that we have a ctor and a dtor, we've got everything we need. From there we can let WeakJSClassCreator implement the more tedious bits for us:

{{{
typedef WeakJSClassCreator<MyClass> CC;
CC c( "MyClass", objectToAddClassTo );
c.Set(...)
 .Set(...)
 .Set(...)
 .Set(...)
 .Seal(); // must be the last setter call made on this object.
}}}

Again, that's all there is to it. Now when we call `new MyClass(...)` from JS, the following will happen:

  * v8 will create a new _JS_ instance of !MyClass (not a native instance).
  * v8 will pass that new JS object to an internal WeakJSClassCreator proxy function which will pass on the arguments to the client-specified specified constructor.
  * If the client-side ctor fails, the internal constructor will throw a JS-side exception (there is no other way to notify JS of a failed construction).
  * If the client ctor succeeds, the internal ctor will then set up a weak pointer callback, which will cause the client-specified dtor to be called _if_ the v8 GC ever decides to kick in. The internal ctor also packs the new native pointer into an internal field of the JS object for later reference by bound functions.

The native object can be fetched later by passing a bound JS object to one of the static methods `WeakJSClassCreator::GetSelf()` or `WeakJSClassCreator::GetObject()`, both of which work similarly but have very slightly different semantics.

Clients can use the `v8::juice::bind` and `v8::juice::cleanup` APIs in their ctors and dtors to get enhanced (and type-safe) type conversions and "supplemental" GC support. See the API docs for more details.