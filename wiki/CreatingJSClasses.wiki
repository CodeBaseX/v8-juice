#summary Creating JS classes from C++
#labels Phase-UserDocs,Featured

<wiki:toc max_depth="3" />

=Introduction=

The JSClassCreator and WeakJSClassCreator classes are helpers which encapsulate
much of the drudge work associated with binding a native class to JS. This page
describes how to use them.

This API is likely to be continually tweaked, so if you use this API be prepared for changes down the road.

==Getting the source code==

While this code is part of v8-juice, much of it is independent of any
other v8-juice library components, which means it be extracted from the
v8-juice source tree for use in other v8-based projects. The source
files are:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/JSClassCreator.h JSClassCreator.h]
  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/juice/JSClassCreator.cc JSClassCreator.cc]
  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/WeakJSClassCreator.h WeakJSClassCreator.h]


=JSClassCreator=

The base binding class, JSClassCreator is suitable for creating new JS
classes which do not need to link to a specific native instance, or want
(or need) to do their own handling binding/unbinding of those instances.
The WeakJSClassCreator subclass adds the ability to automatically handle
the binding/unbinding of a native object to/from the garbage collection
system (in v8 this is called a "weak persistent pointer").

{{{
// JS-side constructor for MyClass objects...
Handle<Value> MyClass_ctor( Arguments const & argv );

// In your JS init code:
JSClassCreator binder( "MyClass", // JS class name
		targetObject, // "global" object (the class we be installed here)
		MyClass_ctor, // constructor callback
		1 ); 	// # of internal fields to reserve
binder.Set( "funcOne", my_callback_func )
      .Set( "valOne", String::New("hi there!") )
      ... more setters ...
      .Seal(); // Seal() MUST come last!
}}}

With the JSClassCreator, the client is responsible for:

  * In the ctor, put your native object somewhere where member native functions can get to it (e.g. put it in an Internal field in the JS new object).
  * In member functions, extract the native element as needed.

(The WeakJSClassCreator does those things for your, but lets start with the basics before we skip to that.)

Once that's in place we can do the following from JS:

{{{
var obj = new MyClass(...);
}}}

For the most basic cases, that's all that necessary, in terms of C++
setup. However, the most significantly missing feature of !MyClass is
memory management. v8 provides a callback mechanism with which we can be
notified "when a context no longer needs an object." The callback
mechanism is, due to v8 design decisions, not 100% reliable (there is
never a _guaranty_ that our callback will be called!), which makes it
useless as a basis for resource management when destructors of certain
types _must_ be called to avoid resource leaks, data corruption, etc. To
be clear, when your application exits, the memory used by your bindings
_will_ be freed, but if they are not GC'd before that then their
_destructors_ will not be called. For most types a missing dtor call is
not all that critical, assuming the application is exiting anyway, but
for some types it's essential for proper operation.

=Backing up a bit: the garbage collection problem=

Let's back up a moment and describe the overall problem:

When an object is created in JavaScript, there is normally no client-visible "native" component to that value - it is an opaque type defined by v8, and has no visible association with a native value. That's all fine and good because the JS engine takes care of cleaning up those objects when it no longer needs them. When "binding" native classes to JS, we invariably associate a JS class with an instance of a C++ class (or some other native type - it need not be a class, e.g. it may be an opaque pointer type from a third-party C library). To do such bindings effectively we need at least these components:

  * A way to internally associate the native data with the JS object. In v8 this is done using `v8::Object::SetInternalField()` and the `v8::External` type. In fact, `v8::External` is the _only_ option for us here, because it is the only v8 type for which we can get a stable unique-per-process value (`External::Value()`), and having some sort of lookup key (in this case a void pointer) is an essential component of binding classes.
  * We "should" have a way to be notified when the JS part of an object is destroyed. In v8 this is accomplished by registering a "weak pointer" callback with the JS object. That callback will be called when (_if_) the v8 GC decides that there are no JS-side references to the object. When this callback is triggered, we can take care of properly deleting the native object and unbinding it from JS-land.

In practice there are a few wrinkles in that story, but we will skip over those now for the sake of clarity, and will touch on them again later on.

The documentation for v8's weak pointers support is a bit spotty, and one can easily spend hours experimenting before the first attempts at class wrapping work. _Or_ we can use WeakJSClassCreator, which was authored after many hours of painful experimentation and sorting through the vague documentation regarding weak pointers in v8...

=WeakJSClassCreator=

The WeakJSClassCreator is a JSClassCreator subclass which uses C++
templates to create functions for binding and unbinding JS objects
to/from native objects of a given type. It is based on the v8 "weak
persistent pointers" concept, and thus its odd name. It is used mostly
like JSClassCreator, the notable difference being a template
argument. As a template argument it takes a native type on whos behalf
it should act. In addition, client code must provide a `WeakJSClassCreatorOps<MyType>` 
class template specialization for each bound type. That class is described fully in the API docs and briefly shown here:

{{{
namespace v8 { namespace juice {
    template <>
    struct WeakJSClassCreatorOps<MyClass>
    {
	/** The actual wrapped native type (may differ from the
            template arg in some cases!). */
	typedef MyClass WrappedType;

	/** Number of internal JS Object fields client needs for
	    his own use. */	
	enum { ExtraInternalFieldCount = 0 };

	/** Constructor function. */
	static WrappedType * Ctor( Arguments const &  /*argv*/,
				   std::string & /*exceptionText*/);

	/** Destructor function. */
	static void Dtor( WrappedType * obj );

	/** The JS class name. */
	static char const * ClassName() { return "MyClass"; }
    };
}} // namespaces
}}}

Again, the semantics of the API are documented in full
[http://code.google.com/p/v8-juice/source/browse/trunk/src/include/v8/juice/WeakJSClassCreator.h in the source code].

In brief:

  * The constructor is responsible for trying to create a `MyClass` object from the given arguments, but it is _not_ responsible for binding that native to the JS object. If it cannot create a new object, it must return 0 and may optionally put some descriptive error string in the given string reference (note that it is not const!), and the internal handler provided by WeakJSClassCreator will convert the error text into a JS-side exception. On success, the ctor must return a new instance of the native object. The internals of WeakJSClassCreator will then bind that native to JS using the weak pointer callback mechanism.
  * The destructor function must destroy the object using some type-specific logic (e.g. `delete obj` for most C++ types). Note that it may be called from the weak pointer trigger or it may be called via client-side action. e.g. a `OutStream.close()` function for a given type might want or need to destroy the native object, and the API provides `WeakJSClassCreator::DestroyObject()` to support that.

Now that we have a ctor and a dtor, we've got everything we need. From there we can let WeakJSClassCreator implement the more tedious bits for us:

{{{
typedef WeakJSClassCreator<MyClass> CC;
CC c( objectToAddClassTo );
c.Set("propertyOne", String::New("Hi, world!"))
 .Set("answer", Integer::New(42))
 .Set(...)
 .Set(...)
 .Seal(); // must be the last setter call made on this object.
}}}

Again, that's all there is to it. Now when we call `new MyClass(...)` from JS, the following will happen:

  * v8 will create a new _JS_ instance of !MyClass (not a native instance).
  * v8 will pass that new JS object to an internal WeakJSClassCreator proxy function which will pass on the arguments to the client-specified specified constructor.
  * If the client-side ctor fails, the internal constructor will throw a JS-side exception (there is no other way to notify JS of a failed construction).
  * If the client ctor succeeds, the internal ctor will then set up a weak pointer callback, which will cause the client-specified dtor to be called _if_ the v8 GC ever decides to kick in. The internal ctor also packs the new native pointer into an internal field of the JS object for later reference by bound functions (see `WeakJSClassCreator::GetSelf()` and `WeakJSClassCreator::GetObject()`).

The native object can be fetched later by passing a bound JS object to
one of the static methods `WeakJSClassCreator::GetSelf()` or
`WeakJSClassCreator::GetNative()`, both of which work similarly but have
very slightly different semantics. The former is expicitly intended to
be pass `argv.This()` from a bound member function, whereas the latter
can be passed a `Handle<Value>` and it will attempt to figure out if
it's of the wrapped native type. The second option is useful when
passing wrapped objects as arguments, as opposed to them being the
`this` object. Both forms use a type-safe conversion and will not crash
if passed a JS reference to an object with a different native type.

It is often useful to destroy a bound object from script code. The
classic example is a `close()` member of a Stream or Database class,
which should free the underlying device handle. This feature is simple
to implement: just call `WeakJSClassCreator::DestroyObject()` from the
appropriate close/destroy routine.

Clients can optionally use the `v8::juice::bind` and
`v8::juice::cleanup` APIs in their ctors and dtors to get enhanced (and
type-safe) type conversions and "supplemental" GC support. Or they can
tie their own supplemental GC by adding the logic to their
`WeakJSClassCreatorOps<T>::Ctor()` and `Dtor()` routines. See the API
docs for more details.

=!ClassBinder=

!ClassBinder is a WeakJSClassCreator subclass which makes use of
v8-juice's type conversions API to add features to the class binding process.
Unlike JSClassCreator and WeakJSClassCreator, !ClassBinder is not a
standalone implementation which can be used as-is in arbitrary v8 client
code - it requires the v8-juice type conversions framework.

The primary feature added by !ClassBinder is the ability to bind native
member functions of the wrapped type. The syntax for doing so is a tiny
bit odd, but there's a reason for it which we'll explain after we
demonstrate:

{{{
int MyClass::func( double ); // function we want to wrap


ClassBinder<MyClass> bin;
bin.AddMemFunc< int /* return value type */,
		double /* first arg type*/,
		&MyClass::func /* member func */
	>( "myFunc" );
}}}

_WTF?_ Every function-wrapping framework i've seen so far passes
function pointers as function arguments to the template functions (got
that?). In this one, we pass the function pointers as a _template
parameter_ instead of as a function argument! Why? It's ugly, but
there's a reason for it: it costs us nothing at runtime. If we passed
pointers to functions as the arguments, we would have to create a small
wrapper object for _each_ binding (that is, one per class/member
combination), and the wrapper's only purpose would be to forward the
call to a specific native object (which is found at runtime of course).
We would have no place to store the call-wrappers for later cleanup (long
story) and we would effectively introduce a memory leak for every bound
function. By using function pointers as template parameters, we bind the
function pointers at compile time and therefor need no intermediary
call-proxy object instance. We _still_ have proxy functions, but they
require no dynamic memory and are bound (and possibly inlined) at
compile-time.

The primary down-side to this approach, as opposed to passing function
pointers as _function_ arguments (not _template_ arguments), is that the
function pointer signature's contained types must exactly match the
types specified in the other template parameters. e.g. the following
will not work:

{{{
int MyClass::func( double );

...

binder.AddMemFunc< int,
		int /* <--- must be of type double because: */,
		&MyClass::func /* int (MyClass::*)(double) */
		>
		("func");
}}}

That won't work because the template type for the first member function
argument is wrong - it must the type used by the signature of the given
member function (so in this case it must be `double` instead of `int`).

If i'm not mistaken, if we bound at runtime to function pointers (via an
internal functor used as a call wrapper), we could rely on implicity
type conversions to do this sort of type conversions for us. That would,
however, require the above-mentioned leak, which i'm not at all keen on.

The conversion of member function parameters to/from JS is achieved
using the `v8::juice::convert` API, and it inherits most of the type
conversion limitations (and features) of that API. As an exception, it supports
member functions returning `void` (which the juice::convert API cannot
directly handle).

TODO: wrapping of const member functions. Requires generation of one or
two more template specializations (per member function arg count) for
some internal types.


=Real-world examples=

There are some real-world examples of using these types in the v8-juice source tree:

  * [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/juice/PathFinder-js.cc Pathfinder-js.cc] is a fairly straightforward example which wraps the `v8::juice::PathFinder` class (or parts of it). Search that file for `SetupPathFinderClass` and you'll jump right to the relevant parts.
  * Or the much more detailed [http://code.google.com/p/v8-juice/source/browse/trunk/src/lib/plugins/whio/v8-whio.cc v8-whio.cc] implements the [PluginWhio whio plugin]. This example is way more convoluted than normal, largely because it contains some evolutionary cruft from the various phases of WeakJSClassCreator's development. It also demonstrates `WeakJSClassCreator<T>` where `WeakJSClassCreator<T>::WrappedType` is-not `T`, which might be interesting to someone out there.