#summary Critic and comments about v8
#labels Topic-BitchAndMoan,Topic-v8

<wiki:toc max_depth="3"/>

=Criticisms=

In my experience, these are the significant problems and caveats associated with binding classes in JS, as demonstration on the [CreatingJSClasses] page.

==The Stack and static functions==

v8's stack-centric API makes it extremely difficult (or even impossible) to keep shared copies of a JS objects for passing around amongst native code. e.g. if we want to make a JS class from the main library or app available to plugins, we can't just have a static copy of JSClassCreator in the main library which we can pass around. Instead, JS data must be be passed around only in JS-space. In my experience, instantiating a static JSClassCreator (or subclass) will crash the app somewhere in v8. That makes some potentially useful features of JSClassCreator, such as the `NewInstance()` member, next to useless (except in the rare case of having to instantiate an instance directly after creating the class).

==Post-`main()` Issues==

Post-`main()` issues are a real-world problem all v8 clients face, especially anyone who wraps classes using the weak pointer mechanism. In short, the problem is this: v8's API, instead of having the user pass around his context info (as in !SpiderMonkey, and as v8 should do), keeps it all in static/shared functions. Sometime post-`main()`, that data will be destroyed. If we have a wrapped class which is not destroyed by v8 (because its GC didn't kick in) but is destroyed by a supplemental garbage collector (long story), the object being destroyed must not interact with v8 in any way (type conversions, creating new handles, etc.), as v8 may have been destroyed and the class would then crash (again, post-`main()`). Any time you see crashes post-`main()` in v8 client code, the first suspect is delayed destruction of shared objects which live outside v8 but may interact with it. The only known workaround for some of these problems is to not clean up the long-living objects and let them be destroyed without calling their destructors. Indeed, that is the only approach supported by v8 (which never guarantees that it will destruct an object, even if we go through the trouble of registering a destructor), for reasons only the v8 architects comprehend.

==Narrowed Applicability due to Design Constraints==

In my opinion, most of these problems are a direct side-effect of v8 having been primarily designed for use in a single application, namely the Google Chrome browser. (One of the v8 developers admitted so much when he said the reason v8 doesn't guaranty that GC will _ever_ be called was made on the basis of improving Chrome's performance.) This led them to make some design decisions which severely limit the more widespread integration of v8 in other applications. My biggest gripe here is that the JS state is all hidden away in shared data, accessible via static functions, instead of being associated with a context handle which is passed around to all client-side functions which use the API (as in !SpiderMonkey, and that approach eliminates most of the lifetime issues mentioned above).

==Write the Fucking Manual==

Another hindrance is the relative lack of v8 documentation. Most functions and classes aren't documented or have only a single line with no real information. This means a great deal of experimentation in order to find out if something will or won't work in v8 (and another amount of guesswork as to whether it's actually _legal_ to do it that way in v8).

As i enjoy writing, and i tend to write "insane" API docs (to quote one user), i did contact the v8 team about contributing API documentation. However, the process of getting involved in the project is just too much effort for my tastes. Why can't i just upload a patch without having to install (and learn) a custom set of tools? Maybe one day Google will pay me to document v8 (dream on!), but until then using v8 will require a lot more experimentation and guesswork than it really should.